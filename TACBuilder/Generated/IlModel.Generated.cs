//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.11.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Linq;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;
using JetBrains.Annotations;

using JetBrains.Core;
using JetBrains.Diagnostics;
using JetBrains.Collections;
using JetBrains.Collections.Viewable;
using JetBrains.Lifetimes;
using JetBrains.Serialization;
using JetBrains.Rd;
using JetBrains.Rd.Base;
using JetBrains.Rd.Impl;
using JetBrains.Rd.Tasks;
using JetBrains.Rd.Util;
using JetBrains.Rd.Text;


// ReSharper disable RedundantEmptyObjectCreationArgumentList
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantOverflowCheckingContext


namespace org.jacodb.api.net.generated.models
{
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:23</p>
  /// </summary>
  public class IlModel : RdExtBase
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    private IlModel(
    )
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    
    
    protected override long SerializationHash => -5233379986265628042L;
    
    protected override Action<ISerializers> Register => RegisterDeclaredTypesSerializers;
    public static void RegisterDeclaredTypesSerializers(ISerializers serializers)
    {
      serializers.Register(TypeId.Read, TypeId.Write);
      serializers.Register(IlPointerTypeDto.Read, IlPointerTypeDto.Write);
      serializers.Register(IlPrimitiveTypeDto.Read, IlPrimitiveTypeDto.Write);
      serializers.Register(IlEnumTypeDto.Read, IlEnumTypeDto.Write);
      serializers.Register(IlStructTypeDto.Read, IlStructTypeDto.Write);
      serializers.Register(IlClassTypeDto.Read, IlClassTypeDto.Write);
      serializers.Register(IlArrayTypeDto.Read, IlArrayTypeDto.Write);
      serializers.Register(IlAttrDto.Read, IlAttrDto.Write);
      serializers.Register(IlFieldDto.Read, IlFieldDto.Write);
      serializers.Register(IlLocalVarDto.Read, IlLocalVarDto.Write);
      serializers.Register(IlTempVarDto.Read, IlTempVarDto.Write);
      serializers.Register(IlErrVarDto.Read, IlErrVarDto.Write);
      serializers.Register(IlCatchScopeDto.Read, IlCatchScopeDto.Write);
      serializers.Register(IlFilterScopeDto.Read, IlFilterScopeDto.Write);
      serializers.Register(IlFaultScopeDto.Read, IlFaultScopeDto.Write);
      serializers.Register(IlFinallyScopeDto.Read, IlFinallyScopeDto.Write);
      serializers.Register(IlMethodDto.Read, IlMethodDto.Write);
      serializers.Register(IlSignatureDto.Read, IlSignatureDto.Write);
      serializers.Register(TypeIdBase_Unknown.Read, TypeIdBase_Unknown.Write);
      serializers.Register(IlDto_Unknown.Read, IlDto_Unknown.Write);
      serializers.Register(IlTypeDto_Unknown.Read, IlTypeDto_Unknown.Write);
      serializers.Register(IlValueTypeDto_Unknown.Read, IlValueTypeDto_Unknown.Write);
      serializers.Register(IlReferenceTypeDto_Unknown.Read, IlReferenceTypeDto_Unknown.Write);
      serializers.Register(IlVarDto_Unknown.Read, IlVarDto_Unknown.Write);
      serializers.Register(IlEhScopeDto_Unknown.Read, IlEhScopeDto_Unknown.Write);
      
      serializers.RegisterToplevelOnce(typeof(IlRoot), IlRoot.RegisterDeclaredTypesSerializers);
    }
    
    public IlModel(Lifetime lifetime, IProtocol protocol) : this()
    {
      Identify(protocol.Identities, RdId.Root.Mix("IlModel"));
      Bind(lifetime, protocol, "IlModel");
    }
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("IlModel (");
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:77</p>
  /// </summary>
  public sealed class IlArrayTypeDto : IlReferenceTypeDto
  {
    //fields
    //public fields
    [NotNull] public TypeId ElementType {get; private set;}
    
    //private fields
    //primary constructor
    public IlArrayTypeDto(
      [NotNull] TypeId elementType,
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isGenericType,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isGenericType,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
      if (elementType == null) throw new ArgumentNullException("elementType");
      
      ElementType = elementType;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlArrayTypeDto> Read = (ctx, reader) => 
    {
      var asmName = reader.ReadString();
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isGenericType = reader.ReadBool();
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var elementType = TypeId.Read(ctx, reader);
      var _result = new IlArrayTypeDto(elementType, asmName, moduleToken, typeToken, namespaceName, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isGenericType, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlArrayTypeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.AsmName);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsGenericType);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
      TypeId.Write(ctx, writer, value.ElementType);
    };
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlArrayTypeDto) obj);
    }
    public bool Equals(IlArrayTypeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(ElementType, other.ElementType) && AsmName == other.AsmName && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsGenericType == other.IsGenericType && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + ElementType.GetHashCode();
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlArrayTypeDto (");
      using (printer.IndentCookie()) {
        printer.Print("elementType = "); ElementType.PrintEx(printer); printer.Println();
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:80</p>
  /// </summary>
  public sealed class IlAttrDto : IlDto
  {
    //fields
    //public fields
    [NotNull] public TypeId AttrType {get; private set;}
    [NotNull] public List<IlConstDto> CtorArgs {get; private set;}
    [NotNull] public List<string> NamedArgsNames {get; private set;}
    [NotNull] public List<IlConstDto> NamedArgsValues {get; private set;}
    [NotNull] public List<TypeId> GenericArgs {get; private set;}
    
    //private fields
    //primary constructor
    public IlAttrDto(
      [NotNull] TypeId attrType,
      [NotNull] List<IlConstDto> ctorArgs,
      [NotNull] List<string> namedArgsNames,
      [NotNull] List<IlConstDto> namedArgsValues,
      [NotNull] List<TypeId> genericArgs
    )
    {
      if (attrType == null) throw new ArgumentNullException("attrType");
      if (ctorArgs == null) throw new ArgumentNullException("ctorArgs");
      if (namedArgsNames == null) throw new ArgumentNullException("namedArgsNames");
      if (namedArgsValues == null) throw new ArgumentNullException("namedArgsValues");
      if (genericArgs == null) throw new ArgumentNullException("genericArgs");
      
      AttrType = attrType;
      CtorArgs = ctorArgs;
      NamedArgsNames = namedArgsNames;
      NamedArgsValues = namedArgsValues;
      GenericArgs = genericArgs;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlAttrDto> Read = (ctx, reader) => 
    {
      var attrType = TypeId.Read(ctx, reader);
      var ctorArgs = ReadIlConstDtoList(ctx, reader);
      var namedArgsNames = ReadStringList(ctx, reader);
      var namedArgsValues = ReadIlConstDtoList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var _result = new IlAttrDto(attrType, ctorArgs, namedArgsNames, namedArgsValues, genericArgs);
      return _result;
    };
    public static CtxReadDelegate<List<IlConstDto>> ReadIlConstDtoList = IlConstDto.Read.List();
    public static CtxReadDelegate<List<string>> ReadStringList = JetBrains.Rd.Impl.Serializers.ReadString.List();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    
    public static new CtxWriteDelegate<IlAttrDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.AttrType);
      WriteIlConstDtoList(ctx, writer, value.CtorArgs);
      WriteStringList(ctx, writer, value.NamedArgsNames);
      WriteIlConstDtoList(ctx, writer, value.NamedArgsValues);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
    };
    public static  CtxWriteDelegate<List<IlConstDto>> WriteIlConstDtoList = IlConstDto.Write.List();
    public static  CtxWriteDelegate<List<string>> WriteStringList = JetBrains.Rd.Impl.Serializers.WriteString.List();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlAttrDto) obj);
    }
    public bool Equals(IlAttrDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(AttrType, other.AttrType) && CtorArgs.SequenceEqual(other.CtorArgs) && NamedArgsNames.SequenceEqual(other.NamedArgsNames) && NamedArgsValues.SequenceEqual(other.NamedArgsValues) && GenericArgs.SequenceEqual(other.GenericArgs);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AttrType.GetHashCode();
        hash = hash * 31 + CtorArgs.ContentHashCode();
        hash = hash * 31 + NamedArgsNames.ContentHashCode();
        hash = hash * 31 + NamedArgsValues.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlAttrDto (");
      using (printer.IndentCookie()) {
        printer.Print("attrType = "); AttrType.PrintEx(printer); printer.Println();
        printer.Print("ctorArgs = "); CtorArgs.PrintEx(printer); printer.Println();
        printer.Print("namedArgsNames = "); NamedArgsNames.PrintEx(printer); printer.Println();
        printer.Print("namedArgsValues = "); NamedArgsValues.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:122</p>
  /// </summary>
  public sealed class IlCatchScopeDto : IlEhScopeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlCatchScopeDto(
      int tb,
      int te,
      int hb,
      int he
    ) : base (
      tb,
      te,
      hb,
      he
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCatchScopeDto> Read = (ctx, reader) => 
    {
      var tb = reader.ReadInt();
      var te = reader.ReadInt();
      var hb = reader.ReadInt();
      var he = reader.ReadInt();
      var _result = new IlCatchScopeDto(tb, te, hb, he);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlCatchScopeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Tb);
      writer.Write(value.Te);
      writer.Write(value.Hb);
      writer.Write(value.He);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCatchScopeDto) obj);
    }
    public bool Equals(IlCatchScopeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Tb == other.Tb && Te == other.Te && Hb == other.Hb && He == other.He;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Tb.GetHashCode();
        hash = hash * 31 + Te.GetHashCode();
        hash = hash * 31 + Hb.GetHashCode();
        hash = hash * 31 + He.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCatchScopeDto (");
      using (printer.IndentCookie()) {
        printer.Print("tb = "); Tb.PrintEx(printer); printer.Println();
        printer.Print("te = "); Te.PrintEx(printer); printer.Println();
        printer.Print("hb = "); Hb.PrintEx(printer); printer.Println();
        printer.Print("he = "); He.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:76</p>
  /// </summary>
  public sealed class IlClassTypeDto : IlReferenceTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlClassTypeDto(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isGenericType,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isGenericType,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlClassTypeDto> Read = (ctx, reader) => 
    {
      var asmName = reader.ReadString();
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isGenericType = reader.ReadBool();
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var _result = new IlClassTypeDto(asmName, moduleToken, typeToken, namespaceName, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isGenericType, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlClassTypeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.AsmName);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsGenericType);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
    };
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlClassTypeDto) obj);
    }
    public bool Equals(IlClassTypeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return AsmName == other.AsmName && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsGenericType == other.IsGenericType && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlClassTypeDto (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:31</p>
  /// </summary>
  public abstract class IlDto{
    //fields
    //public fields
    
    //private fields
    //primary constructor
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<IlDto> Read = Polymorphic<IlDto>.ReadAbstract(IlDto_Unknown.Read);
    
    public static CtxWriteDelegate<IlDto> Write = Polymorphic<IlDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlDto_Unknown : IlDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlDto_Unknown> Read = (ctx, reader) => 
    {
      var _result = new IlDto_Unknown();
      return _result;
    };
    
    public static new CtxWriteDelegate<IlDto_Unknown> Write = (ctx, writer, value) => 
    {
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlDto_Unknown) obj);
    }
    public bool Equals(IlDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return true;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlDto_Unknown (");
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:116</p>
  /// </summary>
  public abstract class IlEhScopeDto : IlDto
  {
    //fields
    //public fields
    public int Tb {get; private set;}
    public int Te {get; private set;}
    public int Hb {get; private set;}
    public int He {get; private set;}
    
    //private fields
    //primary constructor
    protected IlEhScopeDto(
      int tb,
      int te,
      int hb,
      int he
    )
    {
      Tb = tb;
      Te = te;
      Hb = hb;
      He = he;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlEhScopeDto> Read = Polymorphic<IlEhScopeDto>.ReadAbstract(IlEhScopeDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlEhScopeDto> Write = Polymorphic<IlEhScopeDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlEhScopeDto_Unknown : IlEhScopeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlEhScopeDto_Unknown(
      int tb,
      int te,
      int hb,
      int he
    ) : base (
      tb,
      te,
      hb,
      he
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlEhScopeDto_Unknown> Read = (ctx, reader) => 
    {
      var tb = reader.ReadInt();
      var te = reader.ReadInt();
      var hb = reader.ReadInt();
      var he = reader.ReadInt();
      var _result = new IlEhScopeDto_Unknown(tb, te, hb, he);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlEhScopeDto_Unknown> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Tb);
      writer.Write(value.Te);
      writer.Write(value.Hb);
      writer.Write(value.He);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlEhScopeDto_Unknown) obj);
    }
    public bool Equals(IlEhScopeDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Tb == other.Tb && Te == other.Te && Hb == other.Hb && He == other.He;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Tb.GetHashCode();
        hash = hash * 31 + Te.GetHashCode();
        hash = hash * 31 + Hb.GetHashCode();
        hash = hash * 31 + He.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlEhScopeDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("tb = "); Tb.PrintEx(printer); printer.Println();
        printer.Print("te = "); Te.PrintEx(printer); printer.Println();
        printer.Print("hb = "); Hb.PrintEx(printer); printer.Println();
        printer.Print("he = "); He.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:66</p>
  /// </summary>
  public sealed class IlEnumTypeDto : IlValueTypeDto
  {
    //fields
    //public fields
    [NotNull] public TypeId UnderlyingType {get; private set;}
    [NotNull] public List<string> Names {get; private set;}
    [NotNull] public List<IlConstDto> Values {get; private set;}
    
    //private fields
    //primary constructor
    public IlEnumTypeDto(
      [NotNull] TypeId underlyingType,
      [NotNull] List<string> names,
      [NotNull] List<IlConstDto> values,
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isGenericType,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isGenericType,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
      if (underlyingType == null) throw new ArgumentNullException("underlyingType");
      if (names == null) throw new ArgumentNullException("names");
      if (values == null) throw new ArgumentNullException("values");
      
      UnderlyingType = underlyingType;
      Names = names;
      Values = values;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlEnumTypeDto> Read = (ctx, reader) => 
    {
      var asmName = reader.ReadString();
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isGenericType = reader.ReadBool();
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var underlyingType = TypeId.Read(ctx, reader);
      var names = ReadStringList(ctx, reader);
      var values = ReadIlConstDtoList(ctx, reader);
      var _result = new IlEnumTypeDto(underlyingType, names, values, asmName, moduleToken, typeToken, namespaceName, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isGenericType, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<List<string>> ReadStringList = JetBrains.Rd.Impl.Serializers.ReadString.List();
    public static CtxReadDelegate<List<IlConstDto>> ReadIlConstDtoList = IlConstDto.Read.List();
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlEnumTypeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.AsmName);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsGenericType);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
      TypeId.Write(ctx, writer, value.UnderlyingType);
      WriteStringList(ctx, writer, value.Names);
      WriteIlConstDtoList(ctx, writer, value.Values);
    };
    public static  CtxWriteDelegate<List<string>> WriteStringList = JetBrains.Rd.Impl.Serializers.WriteString.List();
    public static  CtxWriteDelegate<List<IlConstDto>> WriteIlConstDtoList = IlConstDto.Write.List();
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlEnumTypeDto) obj);
    }
    public bool Equals(IlEnumTypeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(UnderlyingType, other.UnderlyingType) && Names.SequenceEqual(other.Names) && Values.SequenceEqual(other.Values) && AsmName == other.AsmName && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsGenericType == other.IsGenericType && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + UnderlyingType.GetHashCode();
        hash = hash * 31 + Names.ContentHashCode();
        hash = hash * 31 + Values.ContentHashCode();
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlEnumTypeDto (");
      using (printer.IndentCookie()) {
        printer.Print("underlyingType = "); UnderlyingType.PrintEx(printer); printer.Println();
        printer.Print("names = "); Names.PrintEx(printer); printer.Println();
        printer.Print("values = "); Values.PrintEx(printer); printer.Println();
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:114</p>
  /// </summary>
  public sealed class IlErrVarDto : IlVarDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlErrVarDto(
      [NotNull] TypeId type,
      int index
    ) : base (
      type,
      index
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlErrVarDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var index = reader.ReadInt();
      var _result = new IlErrVarDto(type, index);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlErrVarDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Index);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlErrVarDto) obj);
    }
    public bool Equals(IlErrVarDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Type, other.Type) && Index == other.Index;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Type.GetHashCode();
        hash = hash * 31 + Index.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlErrVarDto (");
      using (printer.IndentCookie()) {
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("index = "); Index.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:127</p>
  /// </summary>
  public sealed class IlFaultScopeDto : IlEhScopeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlFaultScopeDto(
      int tb,
      int te,
      int hb,
      int he
    ) : base (
      tb,
      te,
      hb,
      he
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlFaultScopeDto> Read = (ctx, reader) => 
    {
      var tb = reader.ReadInt();
      var te = reader.ReadInt();
      var hb = reader.ReadInt();
      var he = reader.ReadInt();
      var _result = new IlFaultScopeDto(tb, te, hb, he);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlFaultScopeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Tb);
      writer.Write(value.Te);
      writer.Write(value.Hb);
      writer.Write(value.He);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlFaultScopeDto) obj);
    }
    public bool Equals(IlFaultScopeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Tb == other.Tb && Te == other.Te && Hb == other.Hb && He == other.He;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Tb.GetHashCode();
        hash = hash * 31 + Te.GetHashCode();
        hash = hash * 31 + Hb.GetHashCode();
        hash = hash * 31 + He.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlFaultScopeDto (");
      using (printer.IndentCookie()) {
        printer.Print("tb = "); Tb.PrintEx(printer); printer.Println();
        printer.Print("te = "); Te.PrintEx(printer); printer.Println();
        printer.Print("hb = "); Hb.PrintEx(printer); printer.Println();
        printer.Print("he = "); He.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:88</p>
  /// </summary>
  public sealed class IlFieldDto : IlDto
  {
    //fields
    //public fields
    [NotNull] public TypeId FieldType {get; private set;}
    public bool IsStatic {get; private set;}
    [NotNull] public string Name {get; private set;}
    [NotNull] public List<IlAttrDto> Attrs {get; private set;}
    public bool IsConstructed {get; private set;}
    
    //private fields
    //primary constructor
    public IlFieldDto(
      [NotNull] TypeId fieldType,
      bool isStatic,
      [NotNull] string name,
      [NotNull] List<IlAttrDto> attrs,
      bool isConstructed
    )
    {
      if (fieldType == null) throw new ArgumentNullException("fieldType");
      if (name == null) throw new ArgumentNullException("name");
      if (attrs == null) throw new ArgumentNullException("attrs");
      
      FieldType = fieldType;
      IsStatic = isStatic;
      Name = name;
      Attrs = attrs;
      IsConstructed = isConstructed;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlFieldDto> Read = (ctx, reader) => 
    {
      var fieldType = TypeId.Read(ctx, reader);
      var isStatic = reader.ReadBool();
      var name = reader.ReadString();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var isConstructed = reader.ReadBool();
      var _result = new IlFieldDto(fieldType, isStatic, name, attrs, isConstructed);
      return _result;
    };
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    
    public static new CtxWriteDelegate<IlFieldDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.FieldType);
      writer.Write(value.IsStatic);
      writer.Write(value.Name);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      writer.Write(value.IsConstructed);
    };
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlFieldDto) obj);
    }
    public bool Equals(IlFieldDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(FieldType, other.FieldType) && IsStatic == other.IsStatic && Name == other.Name && Attrs.SequenceEqual(other.Attrs) && IsConstructed == other.IsConstructed;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + FieldType.GetHashCode();
        hash = hash * 31 + IsStatic.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlFieldDto (");
      using (printer.IndentCookie()) {
        printer.Print("fieldType = "); FieldType.PrintEx(printer); printer.Println();
        printer.Print("isStatic = "); IsStatic.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:124</p>
  /// </summary>
  public sealed class IlFilterScopeDto : IlEhScopeDto
  {
    //fields
    //public fields
    public int Fb {get; private set;}
    
    //private fields
    //primary constructor
    public IlFilterScopeDto(
      int fb,
      int tb,
      int te,
      int hb,
      int he
    ) : base (
      tb,
      te,
      hb,
      he
     ) 
    {
      Fb = fb;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlFilterScopeDto> Read = (ctx, reader) => 
    {
      var tb = reader.ReadInt();
      var te = reader.ReadInt();
      var hb = reader.ReadInt();
      var he = reader.ReadInt();
      var fb = reader.ReadInt();
      var _result = new IlFilterScopeDto(fb, tb, te, hb, he);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlFilterScopeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Tb);
      writer.Write(value.Te);
      writer.Write(value.Hb);
      writer.Write(value.He);
      writer.Write(value.Fb);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlFilterScopeDto) obj);
    }
    public bool Equals(IlFilterScopeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Fb == other.Fb && Tb == other.Tb && Te == other.Te && Hb == other.Hb && He == other.He;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Fb.GetHashCode();
        hash = hash * 31 + Tb.GetHashCode();
        hash = hash * 31 + Te.GetHashCode();
        hash = hash * 31 + Hb.GetHashCode();
        hash = hash * 31 + He.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlFilterScopeDto (");
      using (printer.IndentCookie()) {
        printer.Print("fb = "); Fb.PrintEx(printer); printer.Println();
        printer.Print("tb = "); Tb.PrintEx(printer); printer.Println();
        printer.Print("te = "); Te.PrintEx(printer); printer.Println();
        printer.Print("hb = "); Hb.PrintEx(printer); printer.Println();
        printer.Print("he = "); He.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:128</p>
  /// </summary>
  public sealed class IlFinallyScopeDto : IlEhScopeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlFinallyScopeDto(
      int tb,
      int te,
      int hb,
      int he
    ) : base (
      tb,
      te,
      hb,
      he
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlFinallyScopeDto> Read = (ctx, reader) => 
    {
      var tb = reader.ReadInt();
      var te = reader.ReadInt();
      var hb = reader.ReadInt();
      var he = reader.ReadInt();
      var _result = new IlFinallyScopeDto(tb, te, hb, he);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlFinallyScopeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Tb);
      writer.Write(value.Te);
      writer.Write(value.Hb);
      writer.Write(value.He);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlFinallyScopeDto) obj);
    }
    public bool Equals(IlFinallyScopeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Tb == other.Tb && Te == other.Te && Hb == other.Hb && He == other.He;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Tb.GetHashCode();
        hash = hash * 31 + Te.GetHashCode();
        hash = hash * 31 + Hb.GetHashCode();
        hash = hash * 31 + He.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlFinallyScopeDto (");
      using (printer.IndentCookie()) {
        printer.Print("tb = "); Tb.PrintEx(printer); printer.Println();
        printer.Print("te = "); Te.PrintEx(printer); printer.Println();
        printer.Print("hb = "); Hb.PrintEx(printer); printer.Println();
        printer.Print("he = "); He.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:109</p>
  /// </summary>
  public sealed class IlLocalVarDto : IlVarDto
  {
    //fields
    //public fields
    public bool IsPinned {get; private set;}
    
    //private fields
    //primary constructor
    public IlLocalVarDto(
      bool isPinned,
      [NotNull] TypeId type,
      int index
    ) : base (
      type,
      index
     ) 
    {
      IsPinned = isPinned;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlLocalVarDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var index = reader.ReadInt();
      var isPinned = reader.ReadBool();
      var _result = new IlLocalVarDto(isPinned, type, index);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlLocalVarDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Index);
      writer.Write(value.IsPinned);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlLocalVarDto) obj);
    }
    public bool Equals(IlLocalVarDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return IsPinned == other.IsPinned && Equals(Type, other.Type) && Index == other.Index;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + IsPinned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        hash = hash * 31 + Index.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlLocalVarDto (");
      using (printer.IndentCookie()) {
        printer.Print("isPinned = "); IsPinned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("index = "); Index.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:131</p>
  /// </summary>
  public sealed class IlMethodDto : IlDto
  {
    //fields
    //public fields
    [NotNull] public TypeId ReturnType {get; private set;}
    [NotNull] public List<IlAttrDto> Attrs {get; private set;}
    public bool IsStatic {get; private set;}
    [NotNull] public string Name {get; private set;}
    [NotNull] public List<IlParameterDto> Parameters {get; private set;}
    public bool Resolved {get; private set;}
    [NotNull] public List<IlLocalVarDto> Locals {get; private set;}
    [NotNull] public List<IlTempVarDto> Temps {get; private set;}
    [NotNull] public List<IlErrVarDto> Errs {get; private set;}
    [NotNull] public List<IlEhScopeDto> EhScopes {get; private set;}
    [NotNull] public List<IlStmtDto> RawInstList {get; private set;}
    public bool IsConstructed {get; private set;}
    public bool IsGeneric {get; private set;}
    public bool IsGenericDefinition {get; private set;}
    [NotNull] public string Signature {get; private set;}
    [NotNull] public List<TypeId> GenericArgs {get; private set;}
    
    //private fields
    //primary constructor
    public IlMethodDto(
      [NotNull] TypeId returnType,
      [NotNull] List<IlAttrDto> attrs,
      bool isStatic,
      [NotNull] string name,
      [NotNull] List<IlParameterDto> parameters,
      bool resolved,
      [NotNull] List<IlLocalVarDto> locals,
      [NotNull] List<IlTempVarDto> temps,
      [NotNull] List<IlErrVarDto> errs,
      [NotNull] List<IlEhScopeDto> ehScopes,
      [NotNull] List<IlStmtDto> rawInstList,
      bool isConstructed,
      bool isGeneric,
      bool isGenericDefinition,
      [NotNull] string signature,
      [NotNull] List<TypeId> genericArgs
    )
    {
      if (returnType == null) throw new ArgumentNullException("returnType");
      if (attrs == null) throw new ArgumentNullException("attrs");
      if (name == null) throw new ArgumentNullException("name");
      if (parameters == null) throw new ArgumentNullException("parameters");
      if (locals == null) throw new ArgumentNullException("locals");
      if (temps == null) throw new ArgumentNullException("temps");
      if (errs == null) throw new ArgumentNullException("errs");
      if (ehScopes == null) throw new ArgumentNullException("ehScopes");
      if (rawInstList == null) throw new ArgumentNullException("rawInstList");
      if (signature == null) throw new ArgumentNullException("signature");
      if (genericArgs == null) throw new ArgumentNullException("genericArgs");
      
      ReturnType = returnType;
      Attrs = attrs;
      IsStatic = isStatic;
      Name = name;
      Parameters = parameters;
      Resolved = resolved;
      Locals = locals;
      Temps = temps;
      Errs = errs;
      EhScopes = ehScopes;
      RawInstList = rawInstList;
      IsConstructed = isConstructed;
      IsGeneric = isGeneric;
      IsGenericDefinition = isGenericDefinition;
      Signature = signature;
      GenericArgs = genericArgs;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlMethodDto> Read = (ctx, reader) => 
    {
      var returnType = TypeId.Read(ctx, reader);
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var isStatic = reader.ReadBool();
      var name = reader.ReadString();
      var parameters = ReadIlParameterDtoList(ctx, reader);
      var resolved = reader.ReadBool();
      var locals = ReadIlLocalVarDtoList(ctx, reader);
      var temps = ReadIlTempVarDtoList(ctx, reader);
      var errs = ReadIlErrVarDtoList(ctx, reader);
      var ehScopes = ReadIlEhScopeDtoList(ctx, reader);
      var rawInstList = ReadIlStmtDtoList(ctx, reader);
      var isConstructed = reader.ReadBool();
      var isGeneric = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var signature = reader.ReadString();
      var genericArgs = ReadTypeIdList(ctx, reader);
      var _result = new IlMethodDto(returnType, attrs, isStatic, name, parameters, resolved, locals, temps, errs, ehScopes, rawInstList, isConstructed, isGeneric, isGenericDefinition, signature, genericArgs);
      return _result;
    };
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlParameterDto>> ReadIlParameterDtoList = IlParameterDto.Read.List();
    public static CtxReadDelegate<List<IlLocalVarDto>> ReadIlLocalVarDtoList = IlLocalVarDto.Read.List();
    public static CtxReadDelegate<List<IlTempVarDto>> ReadIlTempVarDtoList = IlTempVarDto.Read.List();
    public static CtxReadDelegate<List<IlErrVarDto>> ReadIlErrVarDtoList = IlErrVarDto.Read.List();
    public static CtxReadDelegate<List<IlEhScopeDto>> ReadIlEhScopeDtoList = IlEhScopeDto.Read.List();
    public static CtxReadDelegate<List<IlStmtDto>> ReadIlStmtDtoList = IlStmtDto.Read.List();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    
    public static new CtxWriteDelegate<IlMethodDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.ReturnType);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      writer.Write(value.IsStatic);
      writer.Write(value.Name);
      WriteIlParameterDtoList(ctx, writer, value.Parameters);
      writer.Write(value.Resolved);
      WriteIlLocalVarDtoList(ctx, writer, value.Locals);
      WriteIlTempVarDtoList(ctx, writer, value.Temps);
      WriteIlErrVarDtoList(ctx, writer, value.Errs);
      WriteIlEhScopeDtoList(ctx, writer, value.EhScopes);
      WriteIlStmtDtoList(ctx, writer, value.RawInstList);
      writer.Write(value.IsConstructed);
      writer.Write(value.IsGeneric);
      writer.Write(value.IsGenericDefinition);
      writer.Write(value.Signature);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
    };
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlParameterDto>> WriteIlParameterDtoList = IlParameterDto.Write.List();
    public static  CtxWriteDelegate<List<IlLocalVarDto>> WriteIlLocalVarDtoList = IlLocalVarDto.Write.List();
    public static  CtxWriteDelegate<List<IlTempVarDto>> WriteIlTempVarDtoList = IlTempVarDto.Write.List();
    public static  CtxWriteDelegate<List<IlErrVarDto>> WriteIlErrVarDtoList = IlErrVarDto.Write.List();
    public static  CtxWriteDelegate<List<IlEhScopeDto>> WriteIlEhScopeDtoList = IlEhScopeDto.Write.List();
    public static  CtxWriteDelegate<List<IlStmtDto>> WriteIlStmtDtoList = IlStmtDto.Write.List();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlMethodDto) obj);
    }
    public bool Equals(IlMethodDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(ReturnType, other.ReturnType) && Attrs.SequenceEqual(other.Attrs) && IsStatic == other.IsStatic && Name == other.Name && Parameters.SequenceEqual(other.Parameters) && Resolved == other.Resolved && Locals.SequenceEqual(other.Locals) && Temps.SequenceEqual(other.Temps) && Errs.SequenceEqual(other.Errs) && EhScopes.SequenceEqual(other.EhScopes) && RawInstList.SequenceEqual(other.RawInstList) && IsConstructed == other.IsConstructed && IsGeneric == other.IsGeneric && IsGenericDefinition == other.IsGenericDefinition && Signature == other.Signature && GenericArgs.SequenceEqual(other.GenericArgs);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + ReturnType.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + IsStatic.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Parameters.ContentHashCode();
        hash = hash * 31 + Resolved.GetHashCode();
        hash = hash * 31 + Locals.ContentHashCode();
        hash = hash * 31 + Temps.ContentHashCode();
        hash = hash * 31 + Errs.ContentHashCode();
        hash = hash * 31 + EhScopes.ContentHashCode();
        hash = hash * 31 + RawInstList.ContentHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + IsGeneric.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + Signature.GetHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlMethodDto (");
      using (printer.IndentCookie()) {
        printer.Print("returnType = "); ReturnType.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("isStatic = "); IsStatic.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("parameters = "); Parameters.PrintEx(printer); printer.Println();
        printer.Print("resolved = "); Resolved.PrintEx(printer); printer.Println();
        printer.Print("locals = "); Locals.PrintEx(printer); printer.Println();
        printer.Print("temps = "); Temps.PrintEx(printer); printer.Println();
        printer.Print("errs = "); Errs.PrintEx(printer); printer.Println();
        printer.Print("ehScopes = "); EhScopes.PrintEx(printer); printer.Println();
        printer.Print("rawInstList = "); RawInstList.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("isGeneric = "); IsGeneric.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("signature = "); Signature.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:96</p>
  /// </summary>
  public sealed class IlParameterDto : IPrintable, IEquatable<IlParameterDto>
  {
    //fields
    //public fields
    public int Index {get; private set;}
    [NotNull] public TypeId Type {get; private set;}
    [NotNull] public string Name {get; private set;}
    [Nullable] public IlConstDto DefaultValue {get; private set;}
    [NotNull] public List<IlAttrDto> Attrs {get; private set;}
    
    //private fields
    //primary constructor
    public IlParameterDto(
      int index,
      [NotNull] TypeId type,
      [NotNull] string name,
      [Nullable] IlConstDto defaultValue,
      [NotNull] List<IlAttrDto> attrs
    )
    {
      if (type == null) throw new ArgumentNullException("type");
      if (name == null) throw new ArgumentNullException("name");
      if (attrs == null) throw new ArgumentNullException("attrs");
      
      Index = index;
      Type = type;
      Name = name;
      DefaultValue = defaultValue;
      Attrs = attrs;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int index, [NotNull] out TypeId type, [NotNull] out string name, [Nullable] out IlConstDto defaultValue, [NotNull] out List<IlAttrDto> attrs)
    {
      index = Index;
      type = Type;
      name = Name;
      defaultValue = DefaultValue;
      attrs = Attrs;
    }
    //statics
    
    public static CtxReadDelegate<IlParameterDto> Read = (ctx, reader) => 
    {
      var index = reader.ReadInt();
      var type = TypeId.Read(ctx, reader);
      var name = reader.ReadString();
      var defaultValue = ReadIlConstDtoNullable(ctx, reader);
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var _result = new IlParameterDto(index, type, name, defaultValue, attrs);
      return _result;
    };
    public static CtxReadDelegate<IlConstDto> ReadIlConstDtoNullable = IlConstDto.Read.NullableClass();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    
    public static CtxWriteDelegate<IlParameterDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Index);
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Name);
      WriteIlConstDtoNullable(ctx, writer, value.DefaultValue);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
    };
    public static  CtxWriteDelegate<IlConstDto> WriteIlConstDtoNullable = IlConstDto.Write.NullableClass();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlParameterDto) obj);
    }
    public bool Equals(IlParameterDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Index == other.Index && Equals(Type, other.Type) && Name == other.Name && Equals(DefaultValue, other.DefaultValue) && Attrs.SequenceEqual(other.Attrs);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Index.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + (DefaultValue != null ? DefaultValue.GetHashCode() : 0);
        hash = hash * 31 + Attrs.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlParameterDto (");
      using (printer.IndentCookie()) {
        printer.Print("index = "); Index.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("defaultValue = "); DefaultValue.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:61</p>
  /// </summary>
  public sealed class IlPointerTypeDto : IlTypeDto
  {
    //fields
    //public fields
    [NotNull] public TypeId TargetType {get; private set;}
    
    //private fields
    //primary constructor
    public IlPointerTypeDto(
      [NotNull] TypeId targetType,
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isGenericType,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isGenericType,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
      if (targetType == null) throw new ArgumentNullException("targetType");
      
      TargetType = targetType;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlPointerTypeDto> Read = (ctx, reader) => 
    {
      var asmName = reader.ReadString();
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isGenericType = reader.ReadBool();
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var targetType = TypeId.Read(ctx, reader);
      var _result = new IlPointerTypeDto(targetType, asmName, moduleToken, typeToken, namespaceName, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isGenericType, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlPointerTypeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.AsmName);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsGenericType);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
      TypeId.Write(ctx, writer, value.TargetType);
    };
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlPointerTypeDto) obj);
    }
    public bool Equals(IlPointerTypeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(TargetType, other.TargetType) && AsmName == other.AsmName && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsGenericType == other.IsGenericType && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TargetType.GetHashCode();
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlPointerTypeDto (");
      using (printer.IndentCookie()) {
        printer.Print("targetType = "); TargetType.PrintEx(printer); printer.Println();
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:65</p>
  /// </summary>
  public sealed class IlPrimitiveTypeDto : IlValueTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlPrimitiveTypeDto(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isGenericType,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isGenericType,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlPrimitiveTypeDto> Read = (ctx, reader) => 
    {
      var asmName = reader.ReadString();
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isGenericType = reader.ReadBool();
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var _result = new IlPrimitiveTypeDto(asmName, moduleToken, typeToken, namespaceName, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isGenericType, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlPrimitiveTypeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.AsmName);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsGenericType);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
    };
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlPrimitiveTypeDto) obj);
    }
    public bool Equals(IlPrimitiveTypeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return AsmName == other.AsmName && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsGenericType == other.IsGenericType && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlPrimitiveTypeDto (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:74</p>
  /// </summary>
  public abstract class IlReferenceTypeDto : IlTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    protected IlReferenceTypeDto(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isGenericType,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isGenericType,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlReferenceTypeDto> Read = Polymorphic<IlReferenceTypeDto>.ReadAbstract(IlReferenceTypeDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlReferenceTypeDto> Write = Polymorphic<IlReferenceTypeDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlReferenceTypeDto_Unknown : IlReferenceTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlReferenceTypeDto_Unknown(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isGenericType,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isGenericType,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlReferenceTypeDto_Unknown> Read = (ctx, reader) => 
    {
      var asmName = reader.ReadString();
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isGenericType = reader.ReadBool();
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var _result = new IlReferenceTypeDto_Unknown(asmName, moduleToken, typeToken, namespaceName, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isGenericType, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlReferenceTypeDto_Unknown> Write = (ctx, writer, value) => 
    {
      writer.Write(value.AsmName);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsGenericType);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
    };
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlReferenceTypeDto_Unknown) obj);
    }
    public bool Equals(IlReferenceTypeDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return AsmName == other.AsmName && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsGenericType == other.IsGenericType && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlReferenceTypeDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:150</p>
  /// </summary>
  public sealed class IlSignatureDto : IlDto
  {
    //fields
    //public fields
    [NotNull] public TypeId ReturnType {get; private set;}
    public bool IsInstance {get; private set;}
    public int GenericParamCount {get; private set;}
    [NotNull] public List<TypeId> ParametersTypes {get; private set;}
    
    //private fields
    //primary constructor
    public IlSignatureDto(
      [NotNull] TypeId returnType,
      bool isInstance,
      int genericParamCount,
      [NotNull] List<TypeId> parametersTypes
    )
    {
      if (returnType == null) throw new ArgumentNullException("returnType");
      if (parametersTypes == null) throw new ArgumentNullException("parametersTypes");
      
      ReturnType = returnType;
      IsInstance = isInstance;
      GenericParamCount = genericParamCount;
      ParametersTypes = parametersTypes;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlSignatureDto> Read = (ctx, reader) => 
    {
      var returnType = TypeId.Read(ctx, reader);
      var isInstance = reader.ReadBool();
      var genericParamCount = reader.ReadInt();
      var parametersTypes = ReadTypeIdList(ctx, reader);
      var _result = new IlSignatureDto(returnType, isInstance, genericParamCount, parametersTypes);
      return _result;
    };
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    
    public static new CtxWriteDelegate<IlSignatureDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.ReturnType);
      writer.Write(value.IsInstance);
      writer.Write(value.GenericParamCount);
      WriteTypeIdList(ctx, writer, value.ParametersTypes);
    };
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlSignatureDto) obj);
    }
    public bool Equals(IlSignatureDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(ReturnType, other.ReturnType) && IsInstance == other.IsInstance && GenericParamCount == other.GenericParamCount && ParametersTypes.SequenceEqual(other.ParametersTypes);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + ReturnType.GetHashCode();
        hash = hash * 31 + IsInstance.GetHashCode();
        hash = hash * 31 + GenericParamCount.GetHashCode();
        hash = hash * 31 + ParametersTypes.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlSignatureDto (");
      using (printer.IndentCookie()) {
        printer.Print("returnType = "); ReturnType.PrintEx(printer); printer.Println();
        printer.Print("isInstance = "); IsInstance.PrintEx(printer); printer.Println();
        printer.Print("genericParamCount = "); GenericParamCount.PrintEx(printer); printer.Println();
        printer.Print("parametersTypes = "); ParametersTypes.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:72</p>
  /// </summary>
  public sealed class IlStructTypeDto : IlValueTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlStructTypeDto(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isGenericType,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isGenericType,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlStructTypeDto> Read = (ctx, reader) => 
    {
      var asmName = reader.ReadString();
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isGenericType = reader.ReadBool();
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var _result = new IlStructTypeDto(asmName, moduleToken, typeToken, namespaceName, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isGenericType, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlStructTypeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.AsmName);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsGenericType);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
    };
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlStructTypeDto) obj);
    }
    public bool Equals(IlStructTypeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return AsmName == other.AsmName && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsGenericType == other.IsGenericType && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlStructTypeDto (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:113</p>
  /// </summary>
  public sealed class IlTempVarDto : IlVarDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlTempVarDto(
      [NotNull] TypeId type,
      int index
    ) : base (
      type,
      index
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlTempVarDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var index = reader.ReadInt();
      var _result = new IlTempVarDto(type, index);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlTempVarDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Index);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlTempVarDto) obj);
    }
    public bool Equals(IlTempVarDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Type, other.Type) && Index == other.Index;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Type.GetHashCode();
        hash = hash * 31 + Index.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlTempVarDto (");
      using (printer.IndentCookie()) {
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("index = "); Index.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:33</p>
  /// </summary>
  public abstract class IlTypeDto : IlDto
  {
    //fields
    //public fields
    [NotNull] public string AsmName {get; private set;}
    public int ModuleToken {get; private set;}
    public int TypeToken {get; private set;}
    [NotNull] public string NamespaceName {get; private set;}
    [NotNull] public string Name {get; private set;}
    [NotNull] public string Fullname {get; private set;}
    public bool IsConstructed {get; private set;}
    [Nullable] public TypeId DeclType {get; private set;}
    [Nullable] public TypeId BaseType {get; private set;}
    [NotNull] public List<TypeId> Interfaces {get; private set;}
    [NotNull] public List<TypeId> GenericArgs {get; private set;}
    public bool IsGenericType {get; private set;}
    public bool IsGenericParam {get; private set;}
    public bool IsGenericDefinition {get; private set;}
    [Nullable] public TypeId GenericDefinition {get; private set;}
    public bool IsCovariant {get; private set;}
    public bool IsContravariant {get; private set;}
    public bool HasRefTypeConstraint {get; private set;}
    public bool HasNotNullValueTypeConstraint {get; private set;}
    public bool HasDefaultCtorConstraint {get; private set;}
    public bool IsValueType {get; private set;}
    public bool IsManaged {get; private set;}
    [NotNull] public List<IlAttrDto> Attrs {get; private set;}
    [NotNull] public List<IlFieldDto> Fields {get; private set;}
    [NotNull] public List<IlMethodDto> Methods {get; private set;}
    
    //private fields
    //primary constructor
    protected IlTypeDto(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isGenericType,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    )
    {
      if (asmName == null) throw new ArgumentNullException("asmName");
      if (namespaceName == null) throw new ArgumentNullException("namespaceName");
      if (name == null) throw new ArgumentNullException("name");
      if (fullname == null) throw new ArgumentNullException("fullname");
      if (interfaces == null) throw new ArgumentNullException("interfaces");
      if (genericArgs == null) throw new ArgumentNullException("genericArgs");
      if (attrs == null) throw new ArgumentNullException("attrs");
      if (fields == null) throw new ArgumentNullException("fields");
      if (methods == null) throw new ArgumentNullException("methods");
      
      AsmName = asmName;
      ModuleToken = moduleToken;
      TypeToken = typeToken;
      NamespaceName = namespaceName;
      Name = name;
      Fullname = fullname;
      IsConstructed = isConstructed;
      DeclType = declType;
      BaseType = baseType;
      Interfaces = interfaces;
      GenericArgs = genericArgs;
      IsGenericType = isGenericType;
      IsGenericParam = isGenericParam;
      IsGenericDefinition = isGenericDefinition;
      GenericDefinition = genericDefinition;
      IsCovariant = isCovariant;
      IsContravariant = isContravariant;
      HasRefTypeConstraint = hasRefTypeConstraint;
      HasNotNullValueTypeConstraint = hasNotNullValueTypeConstraint;
      HasDefaultCtorConstraint = hasDefaultCtorConstraint;
      IsValueType = isValueType;
      IsManaged = isManaged;
      Attrs = attrs;
      Fields = fields;
      Methods = methods;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlTypeDto> Read = Polymorphic<IlTypeDto>.ReadAbstract(IlTypeDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlTypeDto> Write = Polymorphic<IlTypeDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlTypeDto_Unknown : IlTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlTypeDto_Unknown(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isGenericType,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isGenericType,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlTypeDto_Unknown> Read = (ctx, reader) => 
    {
      var asmName = reader.ReadString();
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isGenericType = reader.ReadBool();
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var _result = new IlTypeDto_Unknown(asmName, moduleToken, typeToken, namespaceName, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isGenericType, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlTypeDto_Unknown> Write = (ctx, writer, value) => 
    {
      writer.Write(value.AsmName);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsGenericType);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
    };
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlTypeDto_Unknown) obj);
    }
    public bool Equals(IlTypeDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return AsmName == other.AsmName && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsGenericType == other.IsGenericType && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlTypeDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:64</p>
  /// </summary>
  public abstract class IlValueTypeDto : IlTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    protected IlValueTypeDto(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isGenericType,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isGenericType,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlValueTypeDto> Read = Polymorphic<IlValueTypeDto>.ReadAbstract(IlValueTypeDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlValueTypeDto> Write = Polymorphic<IlValueTypeDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlValueTypeDto_Unknown : IlValueTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlValueTypeDto_Unknown(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isGenericType,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isGenericType,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlValueTypeDto_Unknown> Read = (ctx, reader) => 
    {
      var asmName = reader.ReadString();
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isGenericType = reader.ReadBool();
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var _result = new IlValueTypeDto_Unknown(asmName, moduleToken, typeToken, namespaceName, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isGenericType, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlValueTypeDto_Unknown> Write = (ctx, writer, value) => 
    {
      writer.Write(value.AsmName);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsGenericType);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
    };
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlValueTypeDto_Unknown) obj);
    }
    public bool Equals(IlValueTypeDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return AsmName == other.AsmName && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsGenericType == other.IsGenericType && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlValueTypeDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:104</p>
  /// </summary>
  public abstract class IlVarDto : IlDto
  {
    //fields
    //public fields
    [NotNull] public TypeId Type {get; private set;}
    public int Index {get; private set;}
    
    //private fields
    //primary constructor
    protected IlVarDto(
      [NotNull] TypeId type,
      int index
    )
    {
      if (type == null) throw new ArgumentNullException("type");
      
      Type = type;
      Index = index;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlVarDto> Read = Polymorphic<IlVarDto>.ReadAbstract(IlVarDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlVarDto> Write = Polymorphic<IlVarDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlVarDto_Unknown : IlVarDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlVarDto_Unknown(
      [NotNull] TypeId type,
      int index
    ) : base (
      type,
      index
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlVarDto_Unknown> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var index = reader.ReadInt();
      var _result = new IlVarDto_Unknown(type, index);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlVarDto_Unknown> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Index);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlVarDto_Unknown) obj);
    }
    public bool Equals(IlVarDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Type, other.Type) && Index == other.Index;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Type.GetHashCode();
        hash = hash * 31 + Index.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlVarDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("index = "); Index.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:28</p>
  /// </summary>
  public sealed class TypeId : TypeIdBase
  {
    //fields
    //public fields
    [NotNull] public List<TypeIdBase> TypeArgs {get; private set;}
    
    //private fields
    //primary constructor
    public TypeId(
      [NotNull] List<TypeIdBase> typeArgs,
      [NotNull] string asmName,
      [NotNull] string typeName
    ) : base (
      asmName,
      typeName
     ) 
    {
      if (typeArgs == null) throw new ArgumentNullException("typeArgs");
      
      TypeArgs = typeArgs;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<TypeId> Read = (ctx, reader) => 
    {
      var asmName = reader.ReadString();
      var typeName = reader.ReadString();
      var typeArgs = ReadTypeIdBaseList(ctx, reader);
      var _result = new TypeId(typeArgs, asmName, typeName);
      return _result;
    };
    public static CtxReadDelegate<List<TypeIdBase>> ReadTypeIdBaseList = TypeIdBase.Read.List();
    
    public static new CtxWriteDelegate<TypeId> Write = (ctx, writer, value) => 
    {
      writer.Write(value.AsmName);
      writer.Write(value.TypeName);
      WriteTypeIdBaseList(ctx, writer, value.TypeArgs);
    };
    public static  CtxWriteDelegate<List<TypeIdBase>> WriteTypeIdBaseList = TypeIdBase.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((TypeId) obj);
    }
    public bool Equals(TypeId other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return TypeArgs.SequenceEqual(other.TypeArgs) && AsmName == other.AsmName && TypeName == other.TypeName;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TypeArgs.ContentHashCode();
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + TypeName.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("TypeId (");
      using (printer.IndentCookie()) {
        printer.Print("typeArgs = "); TypeArgs.PrintEx(printer); printer.Println();
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("typeName = "); TypeName.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:24</p>
  /// </summary>
  public abstract class TypeIdBase{
    //fields
    //public fields
    [NotNull] public string AsmName {get; private set;}
    [NotNull] public string TypeName {get; private set;}
    
    //private fields
    //primary constructor
    protected TypeIdBase(
      [NotNull] string asmName,
      [NotNull] string typeName
    )
    {
      if (asmName == null) throw new ArgumentNullException("asmName");
      if (typeName == null) throw new ArgumentNullException("typeName");
      
      AsmName = asmName;
      TypeName = typeName;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<TypeIdBase> Read = Polymorphic<TypeIdBase>.ReadAbstract(TypeIdBase_Unknown.Read);
    
    public static CtxWriteDelegate<TypeIdBase> Write = Polymorphic<TypeIdBase>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class TypeIdBase_Unknown : TypeIdBase
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public TypeIdBase_Unknown(
      [NotNull] string asmName,
      [NotNull] string typeName
    ) : base (
      asmName,
      typeName
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<TypeIdBase_Unknown> Read = (ctx, reader) => 
    {
      var asmName = reader.ReadString();
      var typeName = reader.ReadString();
      var _result = new TypeIdBase_Unknown(asmName, typeName);
      return _result;
    };
    
    public static new CtxWriteDelegate<TypeIdBase_Unknown> Write = (ctx, writer, value) => 
    {
      writer.Write(value.AsmName);
      writer.Write(value.TypeName);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((TypeIdBase_Unknown) obj);
    }
    public bool Equals(TypeIdBase_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return AsmName == other.AsmName && TypeName == other.TypeName;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + TypeName.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("TypeIdBase_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("typeName = "); TypeName.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
}
