//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.11.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Linq;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;
using JetBrains.Annotations;

using JetBrains.Core;
using JetBrains.Diagnostics;
using JetBrains.Collections;
using JetBrains.Collections.Viewable;
using JetBrains.Lifetimes;
using JetBrains.Serialization;
using JetBrains.Rd;
using JetBrains.Rd.Base;
using JetBrains.Rd.Impl;
using JetBrains.Rd.Tasks;
using JetBrains.Rd.Util;
using JetBrains.Rd.Text;


// ReSharper disable RedundantEmptyObjectCreationArgumentList
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantOverflowCheckingContext


namespace org.jacodb.api.net.generated.models
{
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:24</p>
  /// </summary>
  public class IlModel : RdExtBase
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    private IlModel(
    )
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    
    
    protected override long SerializationHash => 5406026626313613222L;
    
    protected override Action<ISerializers> Register => RegisterDeclaredTypesSerializers;
    public static void RegisterDeclaredTypesSerializers(ISerializers serializers)
    {
      serializers.Register(TypeId.Read, TypeId.Write);
      serializers.Register(IlPointerTypeDto.Read, IlPointerTypeDto.Write);
      serializers.Register(IlPrimitiveTypeDto.Read, IlPrimitiveTypeDto.Write);
      serializers.Register(IlEnumTypeDto.Read, IlEnumTypeDto.Write);
      serializers.Register(IlStructTypeDto.Read, IlStructTypeDto.Write);
      serializers.Register(IlClassTypeDto.Read, IlClassTypeDto.Write);
      serializers.Register(IlArrayTypeDto.Read, IlArrayTypeDto.Write);
      serializers.Register(IlAttrDto.Read, IlAttrDto.Write);
      serializers.Register(IlFieldDto.Read, IlFieldDto.Write);
      serializers.Register(IlLocalVarDto.Read, IlLocalVarDto.Write);
      serializers.Register(IlTempVarDto.Read, IlTempVarDto.Write);
      serializers.Register(IlErrVarDto.Read, IlErrVarDto.Write);
      serializers.Register(IlCatchScopeDto.Read, IlCatchScopeDto.Write);
      serializers.Register(IlFilterScopeDto.Read, IlFilterScopeDto.Write);
      serializers.Register(IlFaultScopeDto.Read, IlFaultScopeDto.Write);
      serializers.Register(IlFinallyScopeDto.Read, IlFinallyScopeDto.Write);
      serializers.Register(IlMethodDto.Read, IlMethodDto.Write);
      serializers.Register(IlSignatureDto.Read, IlSignatureDto.Write);
      serializers.Register(TypeIdBase_Unknown.Read, TypeIdBase_Unknown.Write);
      serializers.Register(IlDto_Unknown.Read, IlDto_Unknown.Write);
      serializers.Register(IlTypeDto_Unknown.Read, IlTypeDto_Unknown.Write);
      serializers.Register(IlValueTypeDto_Unknown.Read, IlValueTypeDto_Unknown.Write);
      serializers.Register(IlReferenceTypeDto_Unknown.Read, IlReferenceTypeDto_Unknown.Write);
      serializers.Register(IlVarDto_Unknown.Read, IlVarDto_Unknown.Write);
      serializers.Register(IlEhScopeDto_Unknown.Read, IlEhScopeDto_Unknown.Write);
      
      serializers.RegisterToplevelOnce(typeof(IlRoot), IlRoot.RegisterDeclaredTypesSerializers);
    }
    
    public IlModel(Lifetime lifetime, IProtocol protocol) : this()
    {
      Identify(protocol.Identities, RdId.Root.Mix("IlModel"));
      Bind(lifetime, protocol, "IlModel");
    }
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("IlModel (");
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:91</p>
  /// </summary>
  public sealed class IlArrayTypeDto : IlReferenceTypeDto
  {
    //fields
    //public fields
    [NotNull] public TypeId ElementType {get; private set;}
    
    //private fields
    //primary constructor
    public IlArrayTypeDto(
      [NotNull] TypeId elementType,
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      int size,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isInterface,
      bool isAbstract,
      bool isGenericType,
      [NotNull] List<TypeId> genericParameterConstraints,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      size,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isInterface,
      isAbstract,
      isGenericType,
      genericParameterConstraints,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
      if (elementType == null) throw new ArgumentNullException("elementType");
      
      ElementType = elementType;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlArrayTypeDto> Read = (ctx, reader) => 
    {
      var asmName = ctx.ReadInterned(reader, "InternScope", JetBrains.Rd.Impl.Serializers.ReadString);
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var size = reader.ReadInt();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isInterface = reader.ReadBool();
      var isAbstract = reader.ReadBool();
      var isGenericType = reader.ReadBool();
      var genericParameterConstraints = ReadTypeIdList(ctx, reader);
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var elementType = TypeId.Read(ctx, reader);
      var _result = new IlArrayTypeDto(elementType, asmName, moduleToken, typeToken, namespaceName, size, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isInterface, isAbstract, isGenericType, genericParameterConstraints, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.ReadString.Interned("InternScope");
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlArrayTypeDto> Write = (ctx, writer, value) => 
    {
      ctx.WriteInterned(writer, value.AsmName, "InternScope", JetBrains.Rd.Impl.Serializers.WriteString);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Size);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsInterface);
      writer.Write(value.IsAbstract);
      writer.Write(value.IsGenericType);
      WriteTypeIdList(ctx, writer, value.GenericParameterConstraints);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
      TypeId.Write(ctx, writer, value.ElementType);
    };
    public static  CtxWriteDelegate<string> WriteStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.WriteString.Interned("InternScope");
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlArrayTypeDto) obj);
    }
    public bool Equals(IlArrayTypeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(ElementType, other.ElementType) && Equals(AsmName, other.AsmName) && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Size == other.Size && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsInterface == other.IsInterface && IsAbstract == other.IsAbstract && IsGenericType == other.IsGenericType && GenericParameterConstraints.SequenceEqual(other.GenericParameterConstraints) && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + ElementType.GetHashCode();
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Size.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsInterface.GetHashCode();
        hash = hash * 31 + IsAbstract.GetHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + GenericParameterConstraints.ContentHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlArrayTypeDto (");
      using (printer.IndentCookie()) {
        printer.Print("elementType = "); ElementType.PrintEx(printer); printer.Println();
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("size = "); Size.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isInterface = "); IsInterface.PrintEx(printer); printer.Println();
        printer.Print("isAbstract = "); IsAbstract.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("genericParameterConstraints = "); GenericParameterConstraints.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:95</p>
  /// </summary>
  public sealed class IlAttrDto : IlDto
  {
    //fields
    //public fields
    [NotNull] public TypeId AttrType {get; private set;}
    [NotNull] public List<IlConstDto> CtorArgs {get; private set;}
    [NotNull] public List<string> NamedArgsNames {get; private set;}
    [NotNull] public List<IlConstDto> NamedArgsValues {get; private set;}
    [NotNull] public List<TypeId> GenericArgs {get; private set;}
    
    //private fields
    //primary constructor
    public IlAttrDto(
      [NotNull] TypeId attrType,
      [NotNull] List<IlConstDto> ctorArgs,
      [NotNull] List<string> namedArgsNames,
      [NotNull] List<IlConstDto> namedArgsValues,
      [NotNull] List<TypeId> genericArgs
    )
    {
      if (attrType == null) throw new ArgumentNullException("attrType");
      if (ctorArgs == null) throw new ArgumentNullException("ctorArgs");
      if (namedArgsNames == null) throw new ArgumentNullException("namedArgsNames");
      if (namedArgsValues == null) throw new ArgumentNullException("namedArgsValues");
      if (genericArgs == null) throw new ArgumentNullException("genericArgs");
      
      AttrType = attrType;
      CtorArgs = ctorArgs;
      NamedArgsNames = namedArgsNames;
      NamedArgsValues = namedArgsValues;
      GenericArgs = genericArgs;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlAttrDto> Read = (ctx, reader) => 
    {
      var attrType = TypeId.Read(ctx, reader);
      var ctorArgs = ReadIlConstDtoList(ctx, reader);
      var namedArgsNames = ReadStringList(ctx, reader);
      var namedArgsValues = ReadIlConstDtoList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var _result = new IlAttrDto(attrType, ctorArgs, namedArgsNames, namedArgsValues, genericArgs);
      return _result;
    };
    public static CtxReadDelegate<List<IlConstDto>> ReadIlConstDtoList = IlConstDto.Read.List();
    public static CtxReadDelegate<List<string>> ReadStringList = JetBrains.Rd.Impl.Serializers.ReadString.List();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    
    public static new CtxWriteDelegate<IlAttrDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.AttrType);
      WriteIlConstDtoList(ctx, writer, value.CtorArgs);
      WriteStringList(ctx, writer, value.NamedArgsNames);
      WriteIlConstDtoList(ctx, writer, value.NamedArgsValues);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
    };
    public static  CtxWriteDelegate<List<IlConstDto>> WriteIlConstDtoList = IlConstDto.Write.List();
    public static  CtxWriteDelegate<List<string>> WriteStringList = JetBrains.Rd.Impl.Serializers.WriteString.List();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlAttrDto) obj);
    }
    public bool Equals(IlAttrDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(AttrType, other.AttrType) && CtorArgs.SequenceEqual(other.CtorArgs) && NamedArgsNames.SequenceEqual(other.NamedArgsNames) && NamedArgsValues.SequenceEqual(other.NamedArgsValues) && GenericArgs.SequenceEqual(other.GenericArgs);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AttrType.GetHashCode();
        hash = hash * 31 + CtorArgs.ContentHashCode();
        hash = hash * 31 + NamedArgsNames.ContentHashCode();
        hash = hash * 31 + NamedArgsValues.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlAttrDto (");
      using (printer.IndentCookie()) {
        printer.Print("attrType = "); AttrType.PrintEx(printer); printer.Println();
        printer.Print("ctorArgs = "); CtorArgs.PrintEx(printer); printer.Println();
        printer.Print("namedArgsNames = "); NamedArgsNames.PrintEx(printer); printer.Println();
        printer.Print("namedArgsValues = "); NamedArgsValues.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:140</p>
  /// </summary>
  public sealed class IlCatchScopeDto : IlEhScopeDto
  {
    //fields
    //public fields
    [NotNull] public TypeId ExcType {get; private set;}
    
    //private fields
    //primary constructor
    public IlCatchScopeDto(
      [NotNull] TypeId excType,
      int tb,
      int te,
      int hb,
      int he
    ) : base (
      tb,
      te,
      hb,
      he
     ) 
    {
      if (excType == null) throw new ArgumentNullException("excType");
      
      ExcType = excType;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCatchScopeDto> Read = (ctx, reader) => 
    {
      var tb = reader.ReadInt();
      var te = reader.ReadInt();
      var hb = reader.ReadInt();
      var he = reader.ReadInt();
      var excType = TypeId.Read(ctx, reader);
      var _result = new IlCatchScopeDto(excType, tb, te, hb, he);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlCatchScopeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Tb);
      writer.Write(value.Te);
      writer.Write(value.Hb);
      writer.Write(value.He);
      TypeId.Write(ctx, writer, value.ExcType);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCatchScopeDto) obj);
    }
    public bool Equals(IlCatchScopeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(ExcType, other.ExcType) && Tb == other.Tb && Te == other.Te && Hb == other.Hb && He == other.He;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + ExcType.GetHashCode();
        hash = hash * 31 + Tb.GetHashCode();
        hash = hash * 31 + Te.GetHashCode();
        hash = hash * 31 + Hb.GetHashCode();
        hash = hash * 31 + He.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCatchScopeDto (");
      using (printer.IndentCookie()) {
        printer.Print("excType = "); ExcType.PrintEx(printer); printer.Println();
        printer.Print("tb = "); Tb.PrintEx(printer); printer.Println();
        printer.Print("te = "); Te.PrintEx(printer); printer.Println();
        printer.Print("hb = "); Hb.PrintEx(printer); printer.Println();
        printer.Print("he = "); He.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:89</p>
  /// </summary>
  public sealed class IlClassTypeDto : IlReferenceTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlClassTypeDto(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      int size,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isInterface,
      bool isAbstract,
      bool isGenericType,
      [NotNull] List<TypeId> genericParameterConstraints,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      size,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isInterface,
      isAbstract,
      isGenericType,
      genericParameterConstraints,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlClassTypeDto> Read = (ctx, reader) => 
    {
      var asmName = ctx.ReadInterned(reader, "InternScope", JetBrains.Rd.Impl.Serializers.ReadString);
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var size = reader.ReadInt();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isInterface = reader.ReadBool();
      var isAbstract = reader.ReadBool();
      var isGenericType = reader.ReadBool();
      var genericParameterConstraints = ReadTypeIdList(ctx, reader);
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var _result = new IlClassTypeDto(asmName, moduleToken, typeToken, namespaceName, size, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isInterface, isAbstract, isGenericType, genericParameterConstraints, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.ReadString.Interned("InternScope");
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlClassTypeDto> Write = (ctx, writer, value) => 
    {
      ctx.WriteInterned(writer, value.AsmName, "InternScope", JetBrains.Rd.Impl.Serializers.WriteString);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Size);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsInterface);
      writer.Write(value.IsAbstract);
      writer.Write(value.IsGenericType);
      WriteTypeIdList(ctx, writer, value.GenericParameterConstraints);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
    };
    public static  CtxWriteDelegate<string> WriteStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.WriteString.Interned("InternScope");
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlClassTypeDto) obj);
    }
    public bool Equals(IlClassTypeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(AsmName, other.AsmName) && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Size == other.Size && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsInterface == other.IsInterface && IsAbstract == other.IsAbstract && IsGenericType == other.IsGenericType && GenericParameterConstraints.SequenceEqual(other.GenericParameterConstraints) && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Size.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsInterface.GetHashCode();
        hash = hash * 31 + IsAbstract.GetHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + GenericParameterConstraints.ContentHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlClassTypeDto (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("size = "); Size.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isInterface = "); IsInterface.PrintEx(printer); printer.Println();
        printer.Print("isAbstract = "); IsAbstract.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("genericParameterConstraints = "); GenericParameterConstraints.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:36</p>
  /// </summary>
  public abstract class IlDto{
    //fields
    //public fields
    
    //private fields
    //primary constructor
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<IlDto> Read = Polymorphic<IlDto>.ReadAbstract(IlDto_Unknown.Read);
    
    public static CtxWriteDelegate<IlDto> Write = Polymorphic<IlDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlDto_Unknown : IlDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlDto_Unknown> Read = (ctx, reader) => 
    {
      var _result = new IlDto_Unknown();
      return _result;
    };
    
    public static new CtxWriteDelegate<IlDto_Unknown> Write = (ctx, writer, value) => 
    {
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlDto_Unknown) obj);
    }
    public bool Equals(IlDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return true;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlDto_Unknown (");
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:133</p>
  /// </summary>
  public abstract class IlEhScopeDto : IlDto
  {
    //fields
    //public fields
    public int Tb {get; private set;}
    public int Te {get; private set;}
    public int Hb {get; private set;}
    public int He {get; private set;}
    
    //private fields
    //primary constructor
    protected IlEhScopeDto(
      int tb,
      int te,
      int hb,
      int he
    )
    {
      Tb = tb;
      Te = te;
      Hb = hb;
      He = he;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlEhScopeDto> Read = Polymorphic<IlEhScopeDto>.ReadAbstract(IlEhScopeDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlEhScopeDto> Write = Polymorphic<IlEhScopeDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlEhScopeDto_Unknown : IlEhScopeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlEhScopeDto_Unknown(
      int tb,
      int te,
      int hb,
      int he
    ) : base (
      tb,
      te,
      hb,
      he
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlEhScopeDto_Unknown> Read = (ctx, reader) => 
    {
      var tb = reader.ReadInt();
      var te = reader.ReadInt();
      var hb = reader.ReadInt();
      var he = reader.ReadInt();
      var _result = new IlEhScopeDto_Unknown(tb, te, hb, he);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlEhScopeDto_Unknown> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Tb);
      writer.Write(value.Te);
      writer.Write(value.Hb);
      writer.Write(value.He);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlEhScopeDto_Unknown) obj);
    }
    public bool Equals(IlEhScopeDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Tb == other.Tb && Te == other.Te && Hb == other.Hb && He == other.He;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Tb.GetHashCode();
        hash = hash * 31 + Te.GetHashCode();
        hash = hash * 31 + Hb.GetHashCode();
        hash = hash * 31 + He.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlEhScopeDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("tb = "); Tb.PrintEx(printer); printer.Println();
        printer.Print("te = "); Te.PrintEx(printer); printer.Println();
        printer.Print("hb = "); Hb.PrintEx(printer); printer.Println();
        printer.Print("he = "); He.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:78</p>
  /// </summary>
  public sealed class IlEnumTypeDto : IlValueTypeDto
  {
    //fields
    //public fields
    [NotNull] public TypeId UnderlyingType {get; private set;}
    [NotNull] public List<string> Names {get; private set;}
    [NotNull] public List<IlConstDto> Values {get; private set;}
    
    //private fields
    //primary constructor
    public IlEnumTypeDto(
      [NotNull] TypeId underlyingType,
      [NotNull] List<string> names,
      [NotNull] List<IlConstDto> values,
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      int size,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isInterface,
      bool isAbstract,
      bool isGenericType,
      [NotNull] List<TypeId> genericParameterConstraints,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      size,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isInterface,
      isAbstract,
      isGenericType,
      genericParameterConstraints,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
      if (underlyingType == null) throw new ArgumentNullException("underlyingType");
      if (names == null) throw new ArgumentNullException("names");
      if (values == null) throw new ArgumentNullException("values");
      
      UnderlyingType = underlyingType;
      Names = names;
      Values = values;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlEnumTypeDto> Read = (ctx, reader) => 
    {
      var asmName = ctx.ReadInterned(reader, "InternScope", JetBrains.Rd.Impl.Serializers.ReadString);
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var size = reader.ReadInt();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isInterface = reader.ReadBool();
      var isAbstract = reader.ReadBool();
      var isGenericType = reader.ReadBool();
      var genericParameterConstraints = ReadTypeIdList(ctx, reader);
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var underlyingType = TypeId.Read(ctx, reader);
      var names = ReadStringList(ctx, reader);
      var values = ReadIlConstDtoList(ctx, reader);
      var _result = new IlEnumTypeDto(underlyingType, names, values, asmName, moduleToken, typeToken, namespaceName, size, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isInterface, isAbstract, isGenericType, genericParameterConstraints, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<List<string>> ReadStringList = JetBrains.Rd.Impl.Serializers.ReadString.List();
    public static CtxReadDelegate<List<IlConstDto>> ReadIlConstDtoList = IlConstDto.Read.List();
    public static CtxReadDelegate<string> ReadStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.ReadString.Interned("InternScope");
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlEnumTypeDto> Write = (ctx, writer, value) => 
    {
      ctx.WriteInterned(writer, value.AsmName, "InternScope", JetBrains.Rd.Impl.Serializers.WriteString);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Size);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsInterface);
      writer.Write(value.IsAbstract);
      writer.Write(value.IsGenericType);
      WriteTypeIdList(ctx, writer, value.GenericParameterConstraints);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
      TypeId.Write(ctx, writer, value.UnderlyingType);
      WriteStringList(ctx, writer, value.Names);
      WriteIlConstDtoList(ctx, writer, value.Values);
    };
    public static  CtxWriteDelegate<List<string>> WriteStringList = JetBrains.Rd.Impl.Serializers.WriteString.List();
    public static  CtxWriteDelegate<List<IlConstDto>> WriteIlConstDtoList = IlConstDto.Write.List();
    public static  CtxWriteDelegate<string> WriteStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.WriteString.Interned("InternScope");
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlEnumTypeDto) obj);
    }
    public bool Equals(IlEnumTypeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(UnderlyingType, other.UnderlyingType) && Names.SequenceEqual(other.Names) && Values.SequenceEqual(other.Values) && Equals(AsmName, other.AsmName) && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Size == other.Size && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsInterface == other.IsInterface && IsAbstract == other.IsAbstract && IsGenericType == other.IsGenericType && GenericParameterConstraints.SequenceEqual(other.GenericParameterConstraints) && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + UnderlyingType.GetHashCode();
        hash = hash * 31 + Names.ContentHashCode();
        hash = hash * 31 + Values.ContentHashCode();
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Size.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsInterface.GetHashCode();
        hash = hash * 31 + IsAbstract.GetHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + GenericParameterConstraints.ContentHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlEnumTypeDto (");
      using (printer.IndentCookie()) {
        printer.Print("underlyingType = "); UnderlyingType.PrintEx(printer); printer.Println();
        printer.Print("names = "); Names.PrintEx(printer); printer.Println();
        printer.Print("values = "); Values.PrintEx(printer); printer.Println();
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("size = "); Size.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isInterface = "); IsInterface.PrintEx(printer); printer.Println();
        printer.Print("isAbstract = "); IsAbstract.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("genericParameterConstraints = "); GenericParameterConstraints.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:131</p>
  /// </summary>
  public sealed class IlErrVarDto : IlVarDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlErrVarDto(
      [NotNull] TypeId type,
      int index
    ) : base (
      type,
      index
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlErrVarDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var index = reader.ReadInt();
      var _result = new IlErrVarDto(type, index);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlErrVarDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Index);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlErrVarDto) obj);
    }
    public bool Equals(IlErrVarDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Type, other.Type) && Index == other.Index;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Type.GetHashCode();
        hash = hash * 31 + Index.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlErrVarDto (");
      using (printer.IndentCookie()) {
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("index = "); Index.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:148</p>
  /// </summary>
  public sealed class IlFaultScopeDto : IlEhScopeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlFaultScopeDto(
      int tb,
      int te,
      int hb,
      int he
    ) : base (
      tb,
      te,
      hb,
      he
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlFaultScopeDto> Read = (ctx, reader) => 
    {
      var tb = reader.ReadInt();
      var te = reader.ReadInt();
      var hb = reader.ReadInt();
      var he = reader.ReadInt();
      var _result = new IlFaultScopeDto(tb, te, hb, he);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlFaultScopeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Tb);
      writer.Write(value.Te);
      writer.Write(value.Hb);
      writer.Write(value.He);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlFaultScopeDto) obj);
    }
    public bool Equals(IlFaultScopeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Tb == other.Tb && Te == other.Te && Hb == other.Hb && He == other.He;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Tb.GetHashCode();
        hash = hash * 31 + Te.GetHashCode();
        hash = hash * 31 + Hb.GetHashCode();
        hash = hash * 31 + He.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlFaultScopeDto (");
      using (printer.IndentCookie()) {
        printer.Print("tb = "); Tb.PrintEx(printer); printer.Println();
        printer.Print("te = "); Te.PrintEx(printer); printer.Println();
        printer.Print("hb = "); Hb.PrintEx(printer); printer.Println();
        printer.Print("he = "); He.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:103</p>
  /// </summary>
  public sealed class IlFieldDto : IlDto
  {
    //fields
    //public fields
    [NotNull] public TypeId FieldType {get; private set;}
    public bool IsStatic {get; private set;}
    [NotNull] public string Name {get; private set;}
    [NotNull] public List<IlAttrDto> Attrs {get; private set;}
    public bool IsConstructed {get; private set;}
    public int Offset {get; private set;}
    
    //private fields
    //primary constructor
    public IlFieldDto(
      [NotNull] TypeId fieldType,
      bool isStatic,
      [NotNull] string name,
      [NotNull] List<IlAttrDto> attrs,
      bool isConstructed,
      int offset
    )
    {
      if (fieldType == null) throw new ArgumentNullException("fieldType");
      if (name == null) throw new ArgumentNullException("name");
      if (attrs == null) throw new ArgumentNullException("attrs");
      
      FieldType = fieldType;
      IsStatic = isStatic;
      Name = name;
      Attrs = attrs;
      IsConstructed = isConstructed;
      Offset = offset;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlFieldDto> Read = (ctx, reader) => 
    {
      var fieldType = TypeId.Read(ctx, reader);
      var isStatic = reader.ReadBool();
      var name = reader.ReadString();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var isConstructed = reader.ReadBool();
      var offset = reader.ReadInt();
      var _result = new IlFieldDto(fieldType, isStatic, name, attrs, isConstructed, offset);
      return _result;
    };
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    
    public static new CtxWriteDelegate<IlFieldDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.FieldType);
      writer.Write(value.IsStatic);
      writer.Write(value.Name);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      writer.Write(value.IsConstructed);
      writer.Write(value.Offset);
    };
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlFieldDto) obj);
    }
    public bool Equals(IlFieldDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(FieldType, other.FieldType) && IsStatic == other.IsStatic && Name == other.Name && Attrs.SequenceEqual(other.Attrs) && IsConstructed == other.IsConstructed && Offset == other.Offset;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + FieldType.GetHashCode();
        hash = hash * 31 + IsStatic.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + Offset.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlFieldDto (");
      using (printer.IndentCookie()) {
        printer.Print("fieldType = "); FieldType.PrintEx(printer); printer.Println();
        printer.Print("isStatic = "); IsStatic.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("offset = "); Offset.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:144</p>
  /// </summary>
  public sealed class IlFilterScopeDto : IlEhScopeDto
  {
    //fields
    //public fields
    public int Fb {get; private set;}
    
    //private fields
    //primary constructor
    public IlFilterScopeDto(
      int fb,
      int tb,
      int te,
      int hb,
      int he
    ) : base (
      tb,
      te,
      hb,
      he
     ) 
    {
      Fb = fb;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlFilterScopeDto> Read = (ctx, reader) => 
    {
      var tb = reader.ReadInt();
      var te = reader.ReadInt();
      var hb = reader.ReadInt();
      var he = reader.ReadInt();
      var fb = reader.ReadInt();
      var _result = new IlFilterScopeDto(fb, tb, te, hb, he);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlFilterScopeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Tb);
      writer.Write(value.Te);
      writer.Write(value.Hb);
      writer.Write(value.He);
      writer.Write(value.Fb);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlFilterScopeDto) obj);
    }
    public bool Equals(IlFilterScopeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Fb == other.Fb && Tb == other.Tb && Te == other.Te && Hb == other.Hb && He == other.He;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Fb.GetHashCode();
        hash = hash * 31 + Tb.GetHashCode();
        hash = hash * 31 + Te.GetHashCode();
        hash = hash * 31 + Hb.GetHashCode();
        hash = hash * 31 + He.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlFilterScopeDto (");
      using (printer.IndentCookie()) {
        printer.Print("fb = "); Fb.PrintEx(printer); printer.Println();
        printer.Print("tb = "); Tb.PrintEx(printer); printer.Println();
        printer.Print("te = "); Te.PrintEx(printer); printer.Println();
        printer.Print("hb = "); Hb.PrintEx(printer); printer.Println();
        printer.Print("he = "); He.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:150</p>
  /// </summary>
  public sealed class IlFinallyScopeDto : IlEhScopeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlFinallyScopeDto(
      int tb,
      int te,
      int hb,
      int he
    ) : base (
      tb,
      te,
      hb,
      he
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlFinallyScopeDto> Read = (ctx, reader) => 
    {
      var tb = reader.ReadInt();
      var te = reader.ReadInt();
      var hb = reader.ReadInt();
      var he = reader.ReadInt();
      var _result = new IlFinallyScopeDto(tb, te, hb, he);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlFinallyScopeDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Tb);
      writer.Write(value.Te);
      writer.Write(value.Hb);
      writer.Write(value.He);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlFinallyScopeDto) obj);
    }
    public bool Equals(IlFinallyScopeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Tb == other.Tb && Te == other.Te && Hb == other.Hb && He == other.He;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Tb.GetHashCode();
        hash = hash * 31 + Te.GetHashCode();
        hash = hash * 31 + Hb.GetHashCode();
        hash = hash * 31 + He.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlFinallyScopeDto (");
      using (printer.IndentCookie()) {
        printer.Print("tb = "); Tb.PrintEx(printer); printer.Println();
        printer.Print("te = "); Te.PrintEx(printer); printer.Println();
        printer.Print("hb = "); Hb.PrintEx(printer); printer.Println();
        printer.Print("he = "); He.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:125</p>
  /// </summary>
  public sealed class IlLocalVarDto : IlVarDto
  {
    //fields
    //public fields
    public bool IsPinned {get; private set;}
    
    //private fields
    //primary constructor
    public IlLocalVarDto(
      bool isPinned,
      [NotNull] TypeId type,
      int index
    ) : base (
      type,
      index
     ) 
    {
      IsPinned = isPinned;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlLocalVarDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var index = reader.ReadInt();
      var isPinned = reader.ReadBool();
      var _result = new IlLocalVarDto(isPinned, type, index);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlLocalVarDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Index);
      writer.Write(value.IsPinned);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlLocalVarDto) obj);
    }
    public bool Equals(IlLocalVarDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return IsPinned == other.IsPinned && Equals(Type, other.Type) && Index == other.Index;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + IsPinned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        hash = hash * 31 + Index.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlLocalVarDto (");
      using (printer.IndentCookie()) {
        printer.Print("isPinned = "); IsPinned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("index = "); Index.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:153</p>
  /// </summary>
  public sealed class IlMethodDto : IlDto
  {
    //fields
    //public fields
    [NotNull] public TypeId ReturnType {get; private set;}
    [NotNull] public List<IlAttrDto> Attrs {get; private set;}
    public bool IsStatic {get; private set;}
    public bool IsGeneric {get; private set;}
    public bool IsGenericDefinition {get; private set;}
    [NotNull] public string Signature {get; private set;}
    [NotNull] public string Name {get; private set;}
    [NotNull] public List<IlParameterDto> Parameters {get; private set;}
    [NotNull] public List<TypeId> GenericArgs {get; private set;}
    public bool Resolved {get; private set;}
    [NotNull] public List<IlLocalVarDto> Locals {get; private set;}
    [NotNull] public List<IlTempVarDto> Temps {get; private set;}
    [NotNull] public List<IlErrVarDto> Errs {get; private set;}
    [NotNull] public List<IlEhScopeDto> EhScopes {get; private set;}
    [NotNull] public List<IlStmtDto> RawInstList {get; private set;}
    public bool IsConstructed {get; private set;}
    public bool IsVirtual {get; private set;}
    public bool IsAbstract {get; private set;}
    [Nullable] public InstanceId BaseMethod {get; private set;}
    [Nullable] public string FilePath {get; private set;}
    
    //private fields
    //primary constructor
    public IlMethodDto(
      [NotNull] TypeId returnType,
      [NotNull] List<IlAttrDto> attrs,
      bool isStatic,
      bool isGeneric,
      bool isGenericDefinition,
      [NotNull] string signature,
      [NotNull] string name,
      [NotNull] List<IlParameterDto> parameters,
      [NotNull] List<TypeId> genericArgs,
      bool resolved,
      [NotNull] List<IlLocalVarDto> locals,
      [NotNull] List<IlTempVarDto> temps,
      [NotNull] List<IlErrVarDto> errs,
      [NotNull] List<IlEhScopeDto> ehScopes,
      [NotNull] List<IlStmtDto> rawInstList,
      bool isConstructed,
      bool isVirtual,
      bool isAbstract,
      [Nullable] InstanceId baseMethod,
      [Nullable] string filePath
    )
    {
      if (returnType == null) throw new ArgumentNullException("returnType");
      if (attrs == null) throw new ArgumentNullException("attrs");
      if (signature == null) throw new ArgumentNullException("signature");
      if (name == null) throw new ArgumentNullException("name");
      if (parameters == null) throw new ArgumentNullException("parameters");
      if (genericArgs == null) throw new ArgumentNullException("genericArgs");
      if (locals == null) throw new ArgumentNullException("locals");
      if (temps == null) throw new ArgumentNullException("temps");
      if (errs == null) throw new ArgumentNullException("errs");
      if (ehScopes == null) throw new ArgumentNullException("ehScopes");
      if (rawInstList == null) throw new ArgumentNullException("rawInstList");
      
      ReturnType = returnType;
      Attrs = attrs;
      IsStatic = isStatic;
      IsGeneric = isGeneric;
      IsGenericDefinition = isGenericDefinition;
      Signature = signature;
      Name = name;
      Parameters = parameters;
      GenericArgs = genericArgs;
      Resolved = resolved;
      Locals = locals;
      Temps = temps;
      Errs = errs;
      EhScopes = ehScopes;
      RawInstList = rawInstList;
      IsConstructed = isConstructed;
      IsVirtual = isVirtual;
      IsAbstract = isAbstract;
      BaseMethod = baseMethod;
      FilePath = filePath;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlMethodDto> Read = (ctx, reader) => 
    {
      var returnType = TypeId.Read(ctx, reader);
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var isStatic = reader.ReadBool();
      var isGeneric = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var signature = reader.ReadString();
      var name = reader.ReadString();
      var parameters = ReadIlParameterDtoList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var resolved = reader.ReadBool();
      var locals = ReadIlLocalVarDtoList(ctx, reader);
      var temps = ReadIlTempVarDtoList(ctx, reader);
      var errs = ReadIlErrVarDtoList(ctx, reader);
      var ehScopes = ReadIlEhScopeDtoList(ctx, reader);
      var rawInstList = ReadIlStmtDtoList(ctx, reader);
      var isConstructed = reader.ReadBool();
      var isVirtual = reader.ReadBool();
      var isAbstract = reader.ReadBool();
      var baseMethod = ReadInstanceIdNullable(ctx, reader);
      var filePath = ReadStringInternedNullable(ctx, reader);
      var _result = new IlMethodDto(returnType, attrs, isStatic, isGeneric, isGenericDefinition, signature, name, parameters, genericArgs, resolved, locals, temps, errs, ehScopes, rawInstList, isConstructed, isVirtual, isAbstract, baseMethod, filePath);
      return _result;
    };
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlParameterDto>> ReadIlParameterDtoList = IlParameterDto.Read.List();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlLocalVarDto>> ReadIlLocalVarDtoList = IlLocalVarDto.Read.List();
    public static CtxReadDelegate<List<IlTempVarDto>> ReadIlTempVarDtoList = IlTempVarDto.Read.List();
    public static CtxReadDelegate<List<IlErrVarDto>> ReadIlErrVarDtoList = IlErrVarDto.Read.List();
    public static CtxReadDelegate<List<IlEhScopeDto>> ReadIlEhScopeDtoList = IlEhScopeDto.Read.List();
    public static CtxReadDelegate<List<IlStmtDto>> ReadIlStmtDtoList = IlStmtDto.Read.List();
    public static CtxReadDelegate<InstanceId> ReadInstanceIdNullable = InstanceId.Read.NullableClass();
    public static CtxReadDelegate<string> ReadStringInternedNullable = JetBrains.Rd.Impl.Serializers.ReadString.Interned("StmtLocInternScope").NullableClass();
    
    public static new CtxWriteDelegate<IlMethodDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.ReturnType);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      writer.Write(value.IsStatic);
      writer.Write(value.IsGeneric);
      writer.Write(value.IsGenericDefinition);
      writer.Write(value.Signature);
      writer.Write(value.Name);
      WriteIlParameterDtoList(ctx, writer, value.Parameters);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.Resolved);
      WriteIlLocalVarDtoList(ctx, writer, value.Locals);
      WriteIlTempVarDtoList(ctx, writer, value.Temps);
      WriteIlErrVarDtoList(ctx, writer, value.Errs);
      WriteIlEhScopeDtoList(ctx, writer, value.EhScopes);
      WriteIlStmtDtoList(ctx, writer, value.RawInstList);
      writer.Write(value.IsConstructed);
      writer.Write(value.IsVirtual);
      writer.Write(value.IsAbstract);
      WriteInstanceIdNullable(ctx, writer, value.BaseMethod);
      WriteStringInternedNullable(ctx, writer, value.FilePath);
    };
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlParameterDto>> WriteIlParameterDtoList = IlParameterDto.Write.List();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlLocalVarDto>> WriteIlLocalVarDtoList = IlLocalVarDto.Write.List();
    public static  CtxWriteDelegate<List<IlTempVarDto>> WriteIlTempVarDtoList = IlTempVarDto.Write.List();
    public static  CtxWriteDelegate<List<IlErrVarDto>> WriteIlErrVarDtoList = IlErrVarDto.Write.List();
    public static  CtxWriteDelegate<List<IlEhScopeDto>> WriteIlEhScopeDtoList = IlEhScopeDto.Write.List();
    public static  CtxWriteDelegate<List<IlStmtDto>> WriteIlStmtDtoList = IlStmtDto.Write.List();
    public static  CtxWriteDelegate<InstanceId> WriteInstanceIdNullable = InstanceId.Write.NullableClass();
    public static  CtxWriteDelegate<string> WriteStringInternedNullable = JetBrains.Rd.Impl.Serializers.WriteString.Interned("StmtLocInternScope").NullableClass();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlMethodDto) obj);
    }
    public bool Equals(IlMethodDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(ReturnType, other.ReturnType) && Attrs.SequenceEqual(other.Attrs) && IsStatic == other.IsStatic && IsGeneric == other.IsGeneric && IsGenericDefinition == other.IsGenericDefinition && Signature == other.Signature && Name == other.Name && Parameters.SequenceEqual(other.Parameters) && GenericArgs.SequenceEqual(other.GenericArgs) && Resolved == other.Resolved && Locals.SequenceEqual(other.Locals) && Temps.SequenceEqual(other.Temps) && Errs.SequenceEqual(other.Errs) && EhScopes.SequenceEqual(other.EhScopes) && RawInstList.SequenceEqual(other.RawInstList) && IsConstructed == other.IsConstructed && IsVirtual == other.IsVirtual && IsAbstract == other.IsAbstract && Equals(BaseMethod, other.BaseMethod) && Equals(FilePath, other.FilePath);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + ReturnType.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + IsStatic.GetHashCode();
        hash = hash * 31 + IsGeneric.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + Signature.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Parameters.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + Resolved.GetHashCode();
        hash = hash * 31 + Locals.ContentHashCode();
        hash = hash * 31 + Temps.ContentHashCode();
        hash = hash * 31 + Errs.ContentHashCode();
        hash = hash * 31 + EhScopes.ContentHashCode();
        hash = hash * 31 + RawInstList.ContentHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + IsVirtual.GetHashCode();
        hash = hash * 31 + IsAbstract.GetHashCode();
        hash = hash * 31 + (BaseMethod != null ? BaseMethod.GetHashCode() : 0);
        hash = hash * 31 + (FilePath != null ? FilePath.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlMethodDto (");
      using (printer.IndentCookie()) {
        printer.Print("returnType = "); ReturnType.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("isStatic = "); IsStatic.PrintEx(printer); printer.Println();
        printer.Print("isGeneric = "); IsGeneric.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("signature = "); Signature.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("parameters = "); Parameters.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("resolved = "); Resolved.PrintEx(printer); printer.Println();
        printer.Print("locals = "); Locals.PrintEx(printer); printer.Println();
        printer.Print("temps = "); Temps.PrintEx(printer); printer.Println();
        printer.Print("errs = "); Errs.PrintEx(printer); printer.Println();
        printer.Print("ehScopes = "); EhScopes.PrintEx(printer); printer.Println();
        printer.Print("rawInstList = "); RawInstList.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("isVirtual = "); IsVirtual.PrintEx(printer); printer.Println();
        printer.Print("isAbstract = "); IsAbstract.PrintEx(printer); printer.Println();
        printer.Print("baseMethod = "); BaseMethod.PrintEx(printer); printer.Println();
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:112</p>
  /// </summary>
  public sealed class IlParameterDto : IPrintable, IEquatable<IlParameterDto>
  {
    //fields
    //public fields
    public int Index {get; private set;}
    [NotNull] public TypeId Type {get; private set;}
    [NotNull] public string Name {get; private set;}
    [Nullable] public IlConstDto DefaultValue {get; private set;}
    [NotNull] public List<IlAttrDto> Attrs {get; private set;}
    
    //private fields
    //primary constructor
    public IlParameterDto(
      int index,
      [NotNull] TypeId type,
      [NotNull] string name,
      [Nullable] IlConstDto defaultValue,
      [NotNull] List<IlAttrDto> attrs
    )
    {
      if (type == null) throw new ArgumentNullException("type");
      if (name == null) throw new ArgumentNullException("name");
      if (attrs == null) throw new ArgumentNullException("attrs");
      
      Index = index;
      Type = type;
      Name = name;
      DefaultValue = defaultValue;
      Attrs = attrs;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int index, [NotNull] out TypeId type, [NotNull] out string name, [Nullable] out IlConstDto defaultValue, [NotNull] out List<IlAttrDto> attrs)
    {
      index = Index;
      type = Type;
      name = Name;
      defaultValue = DefaultValue;
      attrs = Attrs;
    }
    //statics
    
    public static CtxReadDelegate<IlParameterDto> Read = (ctx, reader) => 
    {
      var index = reader.ReadInt();
      var type = TypeId.Read(ctx, reader);
      var name = reader.ReadString();
      var defaultValue = ReadIlConstDtoNullable(ctx, reader);
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var _result = new IlParameterDto(index, type, name, defaultValue, attrs);
      return _result;
    };
    public static CtxReadDelegate<IlConstDto> ReadIlConstDtoNullable = IlConstDto.Read.NullableClass();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    
    public static CtxWriteDelegate<IlParameterDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Index);
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Name);
      WriteIlConstDtoNullable(ctx, writer, value.DefaultValue);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
    };
    public static  CtxWriteDelegate<IlConstDto> WriteIlConstDtoNullable = IlConstDto.Write.NullableClass();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlParameterDto) obj);
    }
    public bool Equals(IlParameterDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Index == other.Index && Equals(Type, other.Type) && Name == other.Name && Equals(DefaultValue, other.DefaultValue) && Attrs.SequenceEqual(other.Attrs);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Index.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + (DefaultValue != null ? DefaultValue.GetHashCode() : 0);
        hash = hash * 31 + Attrs.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlParameterDto (");
      using (printer.IndentCookie()) {
        printer.Print("index = "); Index.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("defaultValue = "); DefaultValue.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:70</p>
  /// </summary>
  public sealed class IlPointerTypeDto : IlTypeDto
  {
    //fields
    //public fields
    [NotNull] public TypeId TargetType {get; private set;}
    
    //private fields
    //primary constructor
    public IlPointerTypeDto(
      [NotNull] TypeId targetType,
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      int size,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isInterface,
      bool isAbstract,
      bool isGenericType,
      [NotNull] List<TypeId> genericParameterConstraints,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      size,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isInterface,
      isAbstract,
      isGenericType,
      genericParameterConstraints,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
      if (targetType == null) throw new ArgumentNullException("targetType");
      
      TargetType = targetType;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlPointerTypeDto> Read = (ctx, reader) => 
    {
      var asmName = ctx.ReadInterned(reader, "InternScope", JetBrains.Rd.Impl.Serializers.ReadString);
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var size = reader.ReadInt();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isInterface = reader.ReadBool();
      var isAbstract = reader.ReadBool();
      var isGenericType = reader.ReadBool();
      var genericParameterConstraints = ReadTypeIdList(ctx, reader);
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var targetType = TypeId.Read(ctx, reader);
      var _result = new IlPointerTypeDto(targetType, asmName, moduleToken, typeToken, namespaceName, size, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isInterface, isAbstract, isGenericType, genericParameterConstraints, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.ReadString.Interned("InternScope");
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlPointerTypeDto> Write = (ctx, writer, value) => 
    {
      ctx.WriteInterned(writer, value.AsmName, "InternScope", JetBrains.Rd.Impl.Serializers.WriteString);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Size);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsInterface);
      writer.Write(value.IsAbstract);
      writer.Write(value.IsGenericType);
      WriteTypeIdList(ctx, writer, value.GenericParameterConstraints);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
      TypeId.Write(ctx, writer, value.TargetType);
    };
    public static  CtxWriteDelegate<string> WriteStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.WriteString.Interned("InternScope");
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlPointerTypeDto) obj);
    }
    public bool Equals(IlPointerTypeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(TargetType, other.TargetType) && Equals(AsmName, other.AsmName) && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Size == other.Size && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsInterface == other.IsInterface && IsAbstract == other.IsAbstract && IsGenericType == other.IsGenericType && GenericParameterConstraints.SequenceEqual(other.GenericParameterConstraints) && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TargetType.GetHashCode();
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Size.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsInterface.GetHashCode();
        hash = hash * 31 + IsAbstract.GetHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + GenericParameterConstraints.ContentHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlPointerTypeDto (");
      using (printer.IndentCookie()) {
        printer.Print("targetType = "); TargetType.PrintEx(printer); printer.Println();
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("size = "); Size.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isInterface = "); IsInterface.PrintEx(printer); printer.Println();
        printer.Print("isAbstract = "); IsAbstract.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("genericParameterConstraints = "); GenericParameterConstraints.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:76</p>
  /// </summary>
  public sealed class IlPrimitiveTypeDto : IlValueTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlPrimitiveTypeDto(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      int size,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isInterface,
      bool isAbstract,
      bool isGenericType,
      [NotNull] List<TypeId> genericParameterConstraints,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      size,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isInterface,
      isAbstract,
      isGenericType,
      genericParameterConstraints,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlPrimitiveTypeDto> Read = (ctx, reader) => 
    {
      var asmName = ctx.ReadInterned(reader, "InternScope", JetBrains.Rd.Impl.Serializers.ReadString);
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var size = reader.ReadInt();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isInterface = reader.ReadBool();
      var isAbstract = reader.ReadBool();
      var isGenericType = reader.ReadBool();
      var genericParameterConstraints = ReadTypeIdList(ctx, reader);
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var _result = new IlPrimitiveTypeDto(asmName, moduleToken, typeToken, namespaceName, size, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isInterface, isAbstract, isGenericType, genericParameterConstraints, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.ReadString.Interned("InternScope");
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlPrimitiveTypeDto> Write = (ctx, writer, value) => 
    {
      ctx.WriteInterned(writer, value.AsmName, "InternScope", JetBrains.Rd.Impl.Serializers.WriteString);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Size);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsInterface);
      writer.Write(value.IsAbstract);
      writer.Write(value.IsGenericType);
      WriteTypeIdList(ctx, writer, value.GenericParameterConstraints);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
    };
    public static  CtxWriteDelegate<string> WriteStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.WriteString.Interned("InternScope");
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlPrimitiveTypeDto) obj);
    }
    public bool Equals(IlPrimitiveTypeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(AsmName, other.AsmName) && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Size == other.Size && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsInterface == other.IsInterface && IsAbstract == other.IsAbstract && IsGenericType == other.IsGenericType && GenericParameterConstraints.SequenceEqual(other.GenericParameterConstraints) && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Size.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsInterface.GetHashCode();
        hash = hash * 31 + IsAbstract.GetHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + GenericParameterConstraints.ContentHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlPrimitiveTypeDto (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("size = "); Size.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isInterface = "); IsInterface.PrintEx(printer); printer.Println();
        printer.Print("isAbstract = "); IsAbstract.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("genericParameterConstraints = "); GenericParameterConstraints.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:87</p>
  /// </summary>
  public abstract class IlReferenceTypeDto : IlTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    protected IlReferenceTypeDto(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      int size,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isInterface,
      bool isAbstract,
      bool isGenericType,
      [NotNull] List<TypeId> genericParameterConstraints,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      size,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isInterface,
      isAbstract,
      isGenericType,
      genericParameterConstraints,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlReferenceTypeDto> Read = Polymorphic<IlReferenceTypeDto>.ReadAbstract(IlReferenceTypeDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlReferenceTypeDto> Write = Polymorphic<IlReferenceTypeDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlReferenceTypeDto_Unknown : IlReferenceTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlReferenceTypeDto_Unknown(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      int size,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isInterface,
      bool isAbstract,
      bool isGenericType,
      [NotNull] List<TypeId> genericParameterConstraints,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      size,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isInterface,
      isAbstract,
      isGenericType,
      genericParameterConstraints,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlReferenceTypeDto_Unknown> Read = (ctx, reader) => 
    {
      var asmName = ctx.ReadInterned(reader, "InternScope", JetBrains.Rd.Impl.Serializers.ReadString);
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var size = reader.ReadInt();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isInterface = reader.ReadBool();
      var isAbstract = reader.ReadBool();
      var isGenericType = reader.ReadBool();
      var genericParameterConstraints = ReadTypeIdList(ctx, reader);
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var _result = new IlReferenceTypeDto_Unknown(asmName, moduleToken, typeToken, namespaceName, size, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isInterface, isAbstract, isGenericType, genericParameterConstraints, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.ReadString.Interned("InternScope");
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlReferenceTypeDto_Unknown> Write = (ctx, writer, value) => 
    {
      ctx.WriteInterned(writer, value.AsmName, "InternScope", JetBrains.Rd.Impl.Serializers.WriteString);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Size);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsInterface);
      writer.Write(value.IsAbstract);
      writer.Write(value.IsGenericType);
      WriteTypeIdList(ctx, writer, value.GenericParameterConstraints);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
    };
    public static  CtxWriteDelegate<string> WriteStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.WriteString.Interned("InternScope");
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlReferenceTypeDto_Unknown) obj);
    }
    public bool Equals(IlReferenceTypeDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(AsmName, other.AsmName) && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Size == other.Size && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsInterface == other.IsInterface && IsAbstract == other.IsAbstract && IsGenericType == other.IsGenericType && GenericParameterConstraints.SequenceEqual(other.GenericParameterConstraints) && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Size.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsInterface.GetHashCode();
        hash = hash * 31 + IsAbstract.GetHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + GenericParameterConstraints.ContentHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlReferenceTypeDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("size = "); Size.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isInterface = "); IsInterface.PrintEx(printer); printer.Println();
        printer.Print("isAbstract = "); IsAbstract.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("genericParameterConstraints = "); GenericParameterConstraints.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:176</p>
  /// </summary>
  public sealed class IlSignatureDto : IlDto
  {
    //fields
    //public fields
    [NotNull] public TypeId ReturnType {get; private set;}
    public bool IsInstance {get; private set;}
    public int GenericParamCount {get; private set;}
    [NotNull] public List<TypeId> ParametersTypes {get; private set;}
    
    //private fields
    //primary constructor
    public IlSignatureDto(
      [NotNull] TypeId returnType,
      bool isInstance,
      int genericParamCount,
      [NotNull] List<TypeId> parametersTypes
    )
    {
      if (returnType == null) throw new ArgumentNullException("returnType");
      if (parametersTypes == null) throw new ArgumentNullException("parametersTypes");
      
      ReturnType = returnType;
      IsInstance = isInstance;
      GenericParamCount = genericParamCount;
      ParametersTypes = parametersTypes;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlSignatureDto> Read = (ctx, reader) => 
    {
      var returnType = TypeId.Read(ctx, reader);
      var isInstance = reader.ReadBool();
      var genericParamCount = reader.ReadInt();
      var parametersTypes = ReadTypeIdList(ctx, reader);
      var _result = new IlSignatureDto(returnType, isInstance, genericParamCount, parametersTypes);
      return _result;
    };
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    
    public static new CtxWriteDelegate<IlSignatureDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.ReturnType);
      writer.Write(value.IsInstance);
      writer.Write(value.GenericParamCount);
      WriteTypeIdList(ctx, writer, value.ParametersTypes);
    };
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlSignatureDto) obj);
    }
    public bool Equals(IlSignatureDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(ReturnType, other.ReturnType) && IsInstance == other.IsInstance && GenericParamCount == other.GenericParamCount && ParametersTypes.SequenceEqual(other.ParametersTypes);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + ReturnType.GetHashCode();
        hash = hash * 31 + IsInstance.GetHashCode();
        hash = hash * 31 + GenericParamCount.GetHashCode();
        hash = hash * 31 + ParametersTypes.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlSignatureDto (");
      using (printer.IndentCookie()) {
        printer.Print("returnType = "); ReturnType.PrintEx(printer); printer.Println();
        printer.Print("isInstance = "); IsInstance.PrintEx(printer); printer.Println();
        printer.Print("genericParamCount = "); GenericParamCount.PrintEx(printer); printer.Println();
        printer.Print("parametersTypes = "); ParametersTypes.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:85</p>
  /// </summary>
  public sealed class IlStructTypeDto : IlValueTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlStructTypeDto(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      int size,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isInterface,
      bool isAbstract,
      bool isGenericType,
      [NotNull] List<TypeId> genericParameterConstraints,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      size,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isInterface,
      isAbstract,
      isGenericType,
      genericParameterConstraints,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlStructTypeDto> Read = (ctx, reader) => 
    {
      var asmName = ctx.ReadInterned(reader, "InternScope", JetBrains.Rd.Impl.Serializers.ReadString);
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var size = reader.ReadInt();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isInterface = reader.ReadBool();
      var isAbstract = reader.ReadBool();
      var isGenericType = reader.ReadBool();
      var genericParameterConstraints = ReadTypeIdList(ctx, reader);
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var _result = new IlStructTypeDto(asmName, moduleToken, typeToken, namespaceName, size, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isInterface, isAbstract, isGenericType, genericParameterConstraints, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.ReadString.Interned("InternScope");
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlStructTypeDto> Write = (ctx, writer, value) => 
    {
      ctx.WriteInterned(writer, value.AsmName, "InternScope", JetBrains.Rd.Impl.Serializers.WriteString);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Size);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsInterface);
      writer.Write(value.IsAbstract);
      writer.Write(value.IsGenericType);
      WriteTypeIdList(ctx, writer, value.GenericParameterConstraints);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
    };
    public static  CtxWriteDelegate<string> WriteStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.WriteString.Interned("InternScope");
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlStructTypeDto) obj);
    }
    public bool Equals(IlStructTypeDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(AsmName, other.AsmName) && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Size == other.Size && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsInterface == other.IsInterface && IsAbstract == other.IsAbstract && IsGenericType == other.IsGenericType && GenericParameterConstraints.SequenceEqual(other.GenericParameterConstraints) && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Size.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsInterface.GetHashCode();
        hash = hash * 31 + IsAbstract.GetHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + GenericParameterConstraints.ContentHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlStructTypeDto (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("size = "); Size.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isInterface = "); IsInterface.PrintEx(printer); printer.Println();
        printer.Print("isAbstract = "); IsAbstract.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("genericParameterConstraints = "); GenericParameterConstraints.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:129</p>
  /// </summary>
  public sealed class IlTempVarDto : IlVarDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlTempVarDto(
      [NotNull] TypeId type,
      int index
    ) : base (
      type,
      index
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlTempVarDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var index = reader.ReadInt();
      var _result = new IlTempVarDto(type, index);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlTempVarDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Index);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlTempVarDto) obj);
    }
    public bool Equals(IlTempVarDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Type, other.Type) && Index == other.Index;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Type.GetHashCode();
        hash = hash * 31 + Index.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlTempVarDto (");
      using (printer.IndentCookie()) {
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("index = "); Index.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:38</p>
  /// </summary>
  public abstract class IlTypeDto : IlDto
  {
    //fields
    //public fields
    [NotNull] public string AsmName {get; private set;}
    public int ModuleToken {get; private set;}
    public int TypeToken {get; private set;}
    [NotNull] public string NamespaceName {get; private set;}
    public int Size {get; private set;}
    [NotNull] public string Name {get; private set;}
    [NotNull] public string Fullname {get; private set;}
    public bool IsConstructed {get; private set;}
    [Nullable] public TypeId DeclType {get; private set;}
    [Nullable] public TypeId BaseType {get; private set;}
    [NotNull] public List<TypeId> Interfaces {get; private set;}
    [NotNull] public List<TypeId> GenericArgs {get; private set;}
    public bool IsInterface {get; private set;}
    public bool IsAbstract {get; private set;}
    public bool IsGenericType {get; private set;}
    [NotNull] public List<TypeId> GenericParameterConstraints {get; private set;}
    public bool IsGenericParam {get; private set;}
    public bool IsGenericDefinition {get; private set;}
    [Nullable] public TypeId GenericDefinition {get; private set;}
    public bool IsCovariant {get; private set;}
    public bool IsContravariant {get; private set;}
    public bool HasRefTypeConstraint {get; private set;}
    public bool HasNotNullValueTypeConstraint {get; private set;}
    public bool HasDefaultCtorConstraint {get; private set;}
    public bool IsValueType {get; private set;}
    public bool IsManaged {get; private set;}
    [NotNull] public List<IlAttrDto> Attrs {get; private set;}
    [NotNull] public List<IlFieldDto> Fields {get; private set;}
    [NotNull] public List<IlMethodDto> Methods {get; private set;}
    
    //private fields
    //primary constructor
    protected IlTypeDto(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      int size,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isInterface,
      bool isAbstract,
      bool isGenericType,
      [NotNull] List<TypeId> genericParameterConstraints,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    )
    {
      if (asmName == null) throw new ArgumentNullException("asmName");
      if (namespaceName == null) throw new ArgumentNullException("namespaceName");
      if (name == null) throw new ArgumentNullException("name");
      if (fullname == null) throw new ArgumentNullException("fullname");
      if (interfaces == null) throw new ArgumentNullException("interfaces");
      if (genericArgs == null) throw new ArgumentNullException("genericArgs");
      if (genericParameterConstraints == null) throw new ArgumentNullException("genericParameterConstraints");
      if (attrs == null) throw new ArgumentNullException("attrs");
      if (fields == null) throw new ArgumentNullException("fields");
      if (methods == null) throw new ArgumentNullException("methods");
      
      AsmName = asmName;
      ModuleToken = moduleToken;
      TypeToken = typeToken;
      NamespaceName = namespaceName;
      Size = size;
      Name = name;
      Fullname = fullname;
      IsConstructed = isConstructed;
      DeclType = declType;
      BaseType = baseType;
      Interfaces = interfaces;
      GenericArgs = genericArgs;
      IsInterface = isInterface;
      IsAbstract = isAbstract;
      IsGenericType = isGenericType;
      GenericParameterConstraints = genericParameterConstraints;
      IsGenericParam = isGenericParam;
      IsGenericDefinition = isGenericDefinition;
      GenericDefinition = genericDefinition;
      IsCovariant = isCovariant;
      IsContravariant = isContravariant;
      HasRefTypeConstraint = hasRefTypeConstraint;
      HasNotNullValueTypeConstraint = hasNotNullValueTypeConstraint;
      HasDefaultCtorConstraint = hasDefaultCtorConstraint;
      IsValueType = isValueType;
      IsManaged = isManaged;
      Attrs = attrs;
      Fields = fields;
      Methods = methods;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlTypeDto> Read = Polymorphic<IlTypeDto>.ReadAbstract(IlTypeDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlTypeDto> Write = Polymorphic<IlTypeDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlTypeDto_Unknown : IlTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlTypeDto_Unknown(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      int size,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isInterface,
      bool isAbstract,
      bool isGenericType,
      [NotNull] List<TypeId> genericParameterConstraints,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      size,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isInterface,
      isAbstract,
      isGenericType,
      genericParameterConstraints,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlTypeDto_Unknown> Read = (ctx, reader) => 
    {
      var asmName = ctx.ReadInterned(reader, "InternScope", JetBrains.Rd.Impl.Serializers.ReadString);
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var size = reader.ReadInt();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isInterface = reader.ReadBool();
      var isAbstract = reader.ReadBool();
      var isGenericType = reader.ReadBool();
      var genericParameterConstraints = ReadTypeIdList(ctx, reader);
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var _result = new IlTypeDto_Unknown(asmName, moduleToken, typeToken, namespaceName, size, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isInterface, isAbstract, isGenericType, genericParameterConstraints, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.ReadString.Interned("InternScope");
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlTypeDto_Unknown> Write = (ctx, writer, value) => 
    {
      ctx.WriteInterned(writer, value.AsmName, "InternScope", JetBrains.Rd.Impl.Serializers.WriteString);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Size);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsInterface);
      writer.Write(value.IsAbstract);
      writer.Write(value.IsGenericType);
      WriteTypeIdList(ctx, writer, value.GenericParameterConstraints);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
    };
    public static  CtxWriteDelegate<string> WriteStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.WriteString.Interned("InternScope");
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlTypeDto_Unknown) obj);
    }
    public bool Equals(IlTypeDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(AsmName, other.AsmName) && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Size == other.Size && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsInterface == other.IsInterface && IsAbstract == other.IsAbstract && IsGenericType == other.IsGenericType && GenericParameterConstraints.SequenceEqual(other.GenericParameterConstraints) && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Size.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsInterface.GetHashCode();
        hash = hash * 31 + IsAbstract.GetHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + GenericParameterConstraints.ContentHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlTypeDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("size = "); Size.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isInterface = "); IsInterface.PrintEx(printer); printer.Println();
        printer.Print("isAbstract = "); IsAbstract.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("genericParameterConstraints = "); GenericParameterConstraints.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:74</p>
  /// </summary>
  public abstract class IlValueTypeDto : IlTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    protected IlValueTypeDto(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      int size,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isInterface,
      bool isAbstract,
      bool isGenericType,
      [NotNull] List<TypeId> genericParameterConstraints,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      size,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isInterface,
      isAbstract,
      isGenericType,
      genericParameterConstraints,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlValueTypeDto> Read = Polymorphic<IlValueTypeDto>.ReadAbstract(IlValueTypeDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlValueTypeDto> Write = Polymorphic<IlValueTypeDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlValueTypeDto_Unknown : IlValueTypeDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlValueTypeDto_Unknown(
      [NotNull] string asmName,
      int moduleToken,
      int typeToken,
      [NotNull] string namespaceName,
      int size,
      [NotNull] string name,
      [NotNull] string fullname,
      bool isConstructed,
      [Nullable] TypeId declType,
      [Nullable] TypeId baseType,
      [NotNull] List<TypeId> interfaces,
      [NotNull] List<TypeId> genericArgs,
      bool isInterface,
      bool isAbstract,
      bool isGenericType,
      [NotNull] List<TypeId> genericParameterConstraints,
      bool isGenericParam,
      bool isGenericDefinition,
      [Nullable] TypeId genericDefinition,
      bool isCovariant,
      bool isContravariant,
      bool hasRefTypeConstraint,
      bool hasNotNullValueTypeConstraint,
      bool hasDefaultCtorConstraint,
      bool isValueType,
      bool isManaged,
      [NotNull] List<IlAttrDto> attrs,
      [NotNull] List<IlFieldDto> fields,
      [NotNull] List<IlMethodDto> methods
    ) : base (
      asmName,
      moduleToken,
      typeToken,
      namespaceName,
      size,
      name,
      fullname,
      isConstructed,
      declType,
      baseType,
      interfaces,
      genericArgs,
      isInterface,
      isAbstract,
      isGenericType,
      genericParameterConstraints,
      isGenericParam,
      isGenericDefinition,
      genericDefinition,
      isCovariant,
      isContravariant,
      hasRefTypeConstraint,
      hasNotNullValueTypeConstraint,
      hasDefaultCtorConstraint,
      isValueType,
      isManaged,
      attrs,
      fields,
      methods
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlValueTypeDto_Unknown> Read = (ctx, reader) => 
    {
      var asmName = ctx.ReadInterned(reader, "InternScope", JetBrains.Rd.Impl.Serializers.ReadString);
      var moduleToken = reader.ReadInt();
      var typeToken = reader.ReadInt();
      var namespaceName = reader.ReadString();
      var size = reader.ReadInt();
      var name = reader.ReadString();
      var fullname = reader.ReadString();
      var isConstructed = reader.ReadBool();
      var declType = ReadTypeIdNullable(ctx, reader);
      var baseType = ReadTypeIdNullable(ctx, reader);
      var interfaces = ReadTypeIdList(ctx, reader);
      var genericArgs = ReadTypeIdList(ctx, reader);
      var isInterface = reader.ReadBool();
      var isAbstract = reader.ReadBool();
      var isGenericType = reader.ReadBool();
      var genericParameterConstraints = ReadTypeIdList(ctx, reader);
      var isGenericParam = reader.ReadBool();
      var isGenericDefinition = reader.ReadBool();
      var genericDefinition = ReadTypeIdNullable(ctx, reader);
      var isCovariant = reader.ReadBool();
      var isContravariant = reader.ReadBool();
      var hasRefTypeConstraint = reader.ReadBool();
      var hasNotNullValueTypeConstraint = reader.ReadBool();
      var hasDefaultCtorConstraint = reader.ReadBool();
      var isValueType = reader.ReadBool();
      var isManaged = reader.ReadBool();
      var attrs = ReadIlAttrDtoList(ctx, reader);
      var fields = ReadIlFieldDtoList(ctx, reader);
      var methods = ReadIlMethodDtoList(ctx, reader);
      var _result = new IlValueTypeDto_Unknown(asmName, moduleToken, typeToken, namespaceName, size, name, fullname, isConstructed, declType, baseType, interfaces, genericArgs, isInterface, isAbstract, isGenericType, genericParameterConstraints, isGenericParam, isGenericDefinition, genericDefinition, isCovariant, isContravariant, hasRefTypeConstraint, hasNotNullValueTypeConstraint, hasDefaultCtorConstraint, isValueType, isManaged, attrs, fields, methods);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.ReadString.Interned("InternScope");
    public static CtxReadDelegate<TypeId> ReadTypeIdNullable = TypeId.Read.NullableClass();
    public static CtxReadDelegate<List<TypeId>> ReadTypeIdList = TypeId.Read.List();
    public static CtxReadDelegate<List<IlAttrDto>> ReadIlAttrDtoList = IlAttrDto.Read.List();
    public static CtxReadDelegate<List<IlFieldDto>> ReadIlFieldDtoList = IlFieldDto.Read.List();
    public static CtxReadDelegate<List<IlMethodDto>> ReadIlMethodDtoList = IlMethodDto.Read.List();
    
    public static new CtxWriteDelegate<IlValueTypeDto_Unknown> Write = (ctx, writer, value) => 
    {
      ctx.WriteInterned(writer, value.AsmName, "InternScope", JetBrains.Rd.Impl.Serializers.WriteString);
      writer.Write(value.ModuleToken);
      writer.Write(value.TypeToken);
      writer.Write(value.NamespaceName);
      writer.Write(value.Size);
      writer.Write(value.Name);
      writer.Write(value.Fullname);
      writer.Write(value.IsConstructed);
      WriteTypeIdNullable(ctx, writer, value.DeclType);
      WriteTypeIdNullable(ctx, writer, value.BaseType);
      WriteTypeIdList(ctx, writer, value.Interfaces);
      WriteTypeIdList(ctx, writer, value.GenericArgs);
      writer.Write(value.IsInterface);
      writer.Write(value.IsAbstract);
      writer.Write(value.IsGenericType);
      WriteTypeIdList(ctx, writer, value.GenericParameterConstraints);
      writer.Write(value.IsGenericParam);
      writer.Write(value.IsGenericDefinition);
      WriteTypeIdNullable(ctx, writer, value.GenericDefinition);
      writer.Write(value.IsCovariant);
      writer.Write(value.IsContravariant);
      writer.Write(value.HasRefTypeConstraint);
      writer.Write(value.HasNotNullValueTypeConstraint);
      writer.Write(value.HasDefaultCtorConstraint);
      writer.Write(value.IsValueType);
      writer.Write(value.IsManaged);
      WriteIlAttrDtoList(ctx, writer, value.Attrs);
      WriteIlFieldDtoList(ctx, writer, value.Fields);
      WriteIlMethodDtoList(ctx, writer, value.Methods);
    };
    public static  CtxWriteDelegate<string> WriteStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.WriteString.Interned("InternScope");
    public static  CtxWriteDelegate<TypeId> WriteTypeIdNullable = TypeId.Write.NullableClass();
    public static  CtxWriteDelegate<List<TypeId>> WriteTypeIdList = TypeId.Write.List();
    public static  CtxWriteDelegate<List<IlAttrDto>> WriteIlAttrDtoList = IlAttrDto.Write.List();
    public static  CtxWriteDelegate<List<IlFieldDto>> WriteIlFieldDtoList = IlFieldDto.Write.List();
    public static  CtxWriteDelegate<List<IlMethodDto>> WriteIlMethodDtoList = IlMethodDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlValueTypeDto_Unknown) obj);
    }
    public bool Equals(IlValueTypeDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(AsmName, other.AsmName) && ModuleToken == other.ModuleToken && TypeToken == other.TypeToken && NamespaceName == other.NamespaceName && Size == other.Size && Name == other.Name && Fullname == other.Fullname && IsConstructed == other.IsConstructed && Equals(DeclType, other.DeclType) && Equals(BaseType, other.BaseType) && Interfaces.SequenceEqual(other.Interfaces) && GenericArgs.SequenceEqual(other.GenericArgs) && IsInterface == other.IsInterface && IsAbstract == other.IsAbstract && IsGenericType == other.IsGenericType && GenericParameterConstraints.SequenceEqual(other.GenericParameterConstraints) && IsGenericParam == other.IsGenericParam && IsGenericDefinition == other.IsGenericDefinition && Equals(GenericDefinition, other.GenericDefinition) && IsCovariant == other.IsCovariant && IsContravariant == other.IsContravariant && HasRefTypeConstraint == other.HasRefTypeConstraint && HasNotNullValueTypeConstraint == other.HasNotNullValueTypeConstraint && HasDefaultCtorConstraint == other.HasDefaultCtorConstraint && IsValueType == other.IsValueType && IsManaged == other.IsManaged && Attrs.SequenceEqual(other.Attrs) && Fields.SequenceEqual(other.Fields) && Methods.SequenceEqual(other.Methods);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + ModuleToken.GetHashCode();
        hash = hash * 31 + TypeToken.GetHashCode();
        hash = hash * 31 + NamespaceName.GetHashCode();
        hash = hash * 31 + Size.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + Fullname.GetHashCode();
        hash = hash * 31 + IsConstructed.GetHashCode();
        hash = hash * 31 + (DeclType != null ? DeclType.GetHashCode() : 0);
        hash = hash * 31 + (BaseType != null ? BaseType.GetHashCode() : 0);
        hash = hash * 31 + Interfaces.ContentHashCode();
        hash = hash * 31 + GenericArgs.ContentHashCode();
        hash = hash * 31 + IsInterface.GetHashCode();
        hash = hash * 31 + IsAbstract.GetHashCode();
        hash = hash * 31 + IsGenericType.GetHashCode();
        hash = hash * 31 + GenericParameterConstraints.ContentHashCode();
        hash = hash * 31 + IsGenericParam.GetHashCode();
        hash = hash * 31 + IsGenericDefinition.GetHashCode();
        hash = hash * 31 + (GenericDefinition != null ? GenericDefinition.GetHashCode() : 0);
        hash = hash * 31 + IsCovariant.GetHashCode();
        hash = hash * 31 + IsContravariant.GetHashCode();
        hash = hash * 31 + HasRefTypeConstraint.GetHashCode();
        hash = hash * 31 + HasNotNullValueTypeConstraint.GetHashCode();
        hash = hash * 31 + HasDefaultCtorConstraint.GetHashCode();
        hash = hash * 31 + IsValueType.GetHashCode();
        hash = hash * 31 + IsManaged.GetHashCode();
        hash = hash * 31 + Attrs.ContentHashCode();
        hash = hash * 31 + Fields.ContentHashCode();
        hash = hash * 31 + Methods.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlValueTypeDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("moduleToken = "); ModuleToken.PrintEx(printer); printer.Println();
        printer.Print("typeToken = "); TypeToken.PrintEx(printer); printer.Println();
        printer.Print("namespaceName = "); NamespaceName.PrintEx(printer); printer.Println();
        printer.Print("size = "); Size.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("fullname = "); Fullname.PrintEx(printer); printer.Println();
        printer.Print("isConstructed = "); IsConstructed.PrintEx(printer); printer.Println();
        printer.Print("declType = "); DeclType.PrintEx(printer); printer.Println();
        printer.Print("baseType = "); BaseType.PrintEx(printer); printer.Println();
        printer.Print("interfaces = "); Interfaces.PrintEx(printer); printer.Println();
        printer.Print("genericArgs = "); GenericArgs.PrintEx(printer); printer.Println();
        printer.Print("isInterface = "); IsInterface.PrintEx(printer); printer.Println();
        printer.Print("isAbstract = "); IsAbstract.PrintEx(printer); printer.Println();
        printer.Print("isGenericType = "); IsGenericType.PrintEx(printer); printer.Println();
        printer.Print("genericParameterConstraints = "); GenericParameterConstraints.PrintEx(printer); printer.Println();
        printer.Print("isGenericParam = "); IsGenericParam.PrintEx(printer); printer.Println();
        printer.Print("isGenericDefinition = "); IsGenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("genericDefinition = "); GenericDefinition.PrintEx(printer); printer.Println();
        printer.Print("isCovariant = "); IsCovariant.PrintEx(printer); printer.Println();
        printer.Print("isContravariant = "); IsContravariant.PrintEx(printer); printer.Println();
        printer.Print("hasRefTypeConstraint = "); HasRefTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasNotNullValueTypeConstraint = "); HasNotNullValueTypeConstraint.PrintEx(printer); printer.Println();
        printer.Print("hasDefaultCtorConstraint = "); HasDefaultCtorConstraint.PrintEx(printer); printer.Println();
        printer.Print("isValueType = "); IsValueType.PrintEx(printer); printer.Println();
        printer.Print("isManaged = "); IsManaged.PrintEx(printer); printer.Println();
        printer.Print("attrs = "); Attrs.PrintEx(printer); printer.Println();
        printer.Print("fields = "); Fields.PrintEx(printer); printer.Println();
        printer.Print("methods = "); Methods.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:120</p>
  /// </summary>
  public abstract class IlVarDto : IlDto
  {
    //fields
    //public fields
    [NotNull] public TypeId Type {get; private set;}
    public int Index {get; private set;}
    
    //private fields
    //primary constructor
    protected IlVarDto(
      [NotNull] TypeId type,
      int index
    )
    {
      if (type == null) throw new ArgumentNullException("type");
      
      Type = type;
      Index = index;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlVarDto> Read = Polymorphic<IlVarDto>.ReadAbstract(IlVarDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlVarDto> Write = Polymorphic<IlVarDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlVarDto_Unknown : IlVarDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlVarDto_Unknown(
      [NotNull] TypeId type,
      int index
    ) : base (
      type,
      index
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlVarDto_Unknown> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var index = reader.ReadInt();
      var _result = new IlVarDto_Unknown(type, index);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlVarDto_Unknown> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Index);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlVarDto_Unknown) obj);
    }
    public bool Equals(IlVarDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Type, other.Type) && Index == other.Index;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Type.GetHashCode();
        hash = hash * 31 + Index.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlVarDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("index = "); Index.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:32</p>
  /// </summary>
  public sealed class TypeId : TypeIdBase
  {
    //fields
    //public fields
    [NotNull] public List<TypeIdBase> TypeArgs {get; private set;}
    
    //private fields
    //primary constructor
    public TypeId(
      [NotNull] List<TypeIdBase> typeArgs,
      [NotNull] string asmName,
      [NotNull] string typeName
    ) : base (
      asmName,
      typeName
     ) 
    {
      if (typeArgs == null) throw new ArgumentNullException("typeArgs");
      
      TypeArgs = typeArgs;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<TypeId> Read = (ctx, reader) => 
    {
      var asmName = ctx.ReadInterned(reader, "InternScope", JetBrains.Rd.Impl.Serializers.ReadString);
      var typeName = reader.ReadString();
      var typeArgs = ReadTypeIdBaseList(ctx, reader);
      var _result = new TypeId(typeArgs, asmName, typeName);
      return _result;
    };
    public static CtxReadDelegate<List<TypeIdBase>> ReadTypeIdBaseList = TypeIdBase.Read.List();
    public static CtxReadDelegate<string> ReadStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.ReadString.Interned("InternScope");
    
    public static new CtxWriteDelegate<TypeId> Write = (ctx, writer, value) => 
    {
      ctx.WriteInterned(writer, value.AsmName, "InternScope", JetBrains.Rd.Impl.Serializers.WriteString);
      writer.Write(value.TypeName);
      WriteTypeIdBaseList(ctx, writer, value.TypeArgs);
    };
    public static  CtxWriteDelegate<List<TypeIdBase>> WriteTypeIdBaseList = TypeIdBase.Write.List();
    public static  CtxWriteDelegate<string> WriteStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.WriteString.Interned("InternScope");
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((TypeId) obj);
    }
    public bool Equals(TypeId other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return TypeArgs.SequenceEqual(other.TypeArgs) && Equals(AsmName, other.AsmName) && TypeName == other.TypeName;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TypeArgs.ContentHashCode();
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + TypeName.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("TypeId (");
      using (printer.IndentCookie()) {
        printer.Print("typeArgs = "); TypeArgs.PrintEx(printer); printer.Println();
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("typeName = "); TypeName.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlModel.kt:27</p>
  /// </summary>
  public abstract class TypeIdBase{
    //fields
    //public fields
    [NotNull] public string AsmName {get; private set;}
    [NotNull] public string TypeName {get; private set;}
    
    //private fields
    //primary constructor
    protected TypeIdBase(
      [NotNull] string asmName,
      [NotNull] string typeName
    )
    {
      if (asmName == null) throw new ArgumentNullException("asmName");
      if (typeName == null) throw new ArgumentNullException("typeName");
      
      AsmName = asmName;
      TypeName = typeName;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<TypeIdBase> Read = Polymorphic<TypeIdBase>.ReadAbstract(TypeIdBase_Unknown.Read);
    
    public static CtxWriteDelegate<TypeIdBase> Write = Polymorphic<TypeIdBase>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class TypeIdBase_Unknown : TypeIdBase
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public TypeIdBase_Unknown(
      [NotNull] string asmName,
      [NotNull] string typeName
    ) : base (
      asmName,
      typeName
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<TypeIdBase_Unknown> Read = (ctx, reader) => 
    {
      var asmName = ctx.ReadInterned(reader, "InternScope", JetBrains.Rd.Impl.Serializers.ReadString);
      var typeName = reader.ReadString();
      var _result = new TypeIdBase_Unknown(asmName, typeName);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.ReadString.Interned("InternScope");
    
    public static new CtxWriteDelegate<TypeIdBase_Unknown> Write = (ctx, writer, value) => 
    {
      ctx.WriteInterned(writer, value.AsmName, "InternScope", JetBrains.Rd.Impl.Serializers.WriteString);
      writer.Write(value.TypeName);
    };
    public static  CtxWriteDelegate<string> WriteStringInternedAtInternScope = JetBrains.Rd.Impl.Serializers.WriteString.Interned("InternScope");
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((TypeIdBase_Unknown) obj);
    }
    public bool Equals(TypeIdBase_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(AsmName, other.AsmName) && TypeName == other.TypeName;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + AsmName.GetHashCode();
        hash = hash * 31 + TypeName.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("TypeIdBase_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("asmName = "); AsmName.PrintEx(printer); printer.Println();
        printer.Print("typeName = "); TypeName.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
}
