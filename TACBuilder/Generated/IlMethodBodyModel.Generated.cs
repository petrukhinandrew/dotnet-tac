//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.11.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Linq;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;
using JetBrains.Annotations;

using JetBrains.Core;
using JetBrains.Diagnostics;
using JetBrains.Collections;
using JetBrains.Collections.Viewable;
using JetBrains.Lifetimes;
using JetBrains.Serialization;
using JetBrains.Rd;
using JetBrains.Rd.Base;
using JetBrains.Rd.Impl;
using JetBrains.Rd.Tasks;
using JetBrains.Rd.Util;
using JetBrains.Rd.Text;


// ReSharper disable RedundantEmptyObjectCreationArgumentList
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantOverflowCheckingContext


namespace org.jacodb.api.net.generated.models
{
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:24</p>
  /// </summary>
  public class IlMethodBodyModel : RdExtBase
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    private IlMethodBodyModel(
    )
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    
    
    protected override long SerializationHash => -452128083975823807L;
    
    protected override Action<ISerializers> Register => RegisterDeclaredTypesSerializers;
    public static void RegisterDeclaredTypesSerializers(ISerializers serializers)
    {
      serializers.Register(IlInt8ConstDto.Read, IlInt8ConstDto.Write);
      serializers.Register(IlUint8ConstDto.Read, IlUint8ConstDto.Write);
      serializers.Register(IlInt16ConstDto.Read, IlInt16ConstDto.Write);
      serializers.Register(IlUint16ConstDto.Read, IlUint16ConstDto.Write);
      serializers.Register(IlInt32ConstDto.Read, IlInt32ConstDto.Write);
      serializers.Register(IlUint32ConstDto.Read, IlUint32ConstDto.Write);
      serializers.Register(IlInt64ConstDto.Read, IlInt64ConstDto.Write);
      serializers.Register(IlUint64ConstDto.Read, IlUint64ConstDto.Write);
      serializers.Register(IlFloatConstDto.Read, IlFloatConstDto.Write);
      serializers.Register(IlDoubleConstDto.Read, IlDoubleConstDto.Write);
      serializers.Register(IlCharConstDto.Read, IlCharConstDto.Write);
      serializers.Register(IlArrayConstDto.Read, IlArrayConstDto.Write);
      serializers.Register(IlEnumConstDto.Read, IlEnumConstDto.Write);
      serializers.Register(IlNullDto.Read, IlNullDto.Write);
      serializers.Register(IlBoolConstDto.Read, IlBoolConstDto.Write);
      serializers.Register(IlStringConstDto.Read, IlStringConstDto.Write);
      serializers.Register(IlTypeRefDto.Read, IlTypeRefDto.Write);
      serializers.Register(IlMethodRefDto.Read, IlMethodRefDto.Write);
      serializers.Register(IlFieldRefDto.Read, IlFieldRefDto.Write);
      serializers.Register(IlNegOpDto.Read, IlNegOpDto.Write);
      serializers.Register(IlNotOpDto.Read, IlNotOpDto.Write);
      serializers.Register(IlAddOpDto.Read, IlAddOpDto.Write);
      serializers.Register(IlSubOpDto.Read, IlSubOpDto.Write);
      serializers.Register(IlMulOpDto.Read, IlMulOpDto.Write);
      serializers.Register(IlDivOpDto.Read, IlDivOpDto.Write);
      serializers.Register(IlRemOpDto.Read, IlRemOpDto.Write);
      serializers.Register(IlAndOpDto.Read, IlAndOpDto.Write);
      serializers.Register(IlOrOpDto.Read, IlOrOpDto.Write);
      serializers.Register(IlXorOpDto.Read, IlXorOpDto.Write);
      serializers.Register(IlShlOpDto.Read, IlShlOpDto.Write);
      serializers.Register(IlShrOpDto.Read, IlShrOpDto.Write);
      serializers.Register(IlCeqOpDto.Read, IlCeqOpDto.Write);
      serializers.Register(IlCneOpDto.Read, IlCneOpDto.Write);
      serializers.Register(IlCgtOpDto.Read, IlCgtOpDto.Write);
      serializers.Register(IlCgeOpDto.Read, IlCgeOpDto.Write);
      serializers.Register(IlCltOpDto.Read, IlCltOpDto.Write);
      serializers.Register(IlCleOpDto.Read, IlCleOpDto.Write);
      serializers.Register(IlNewExprDto.Read, IlNewExprDto.Write);
      serializers.Register(IlSizeOfExprDto.Read, IlSizeOfExprDto.Write);
      serializers.Register(IlFieldAccessDto.Read, IlFieldAccessDto.Write);
      serializers.Register(IlArrayAccessDto.Read, IlArrayAccessDto.Write);
      serializers.Register(IlNewArrayExprDto.Read, IlNewArrayExprDto.Write);
      serializers.Register(IlArrayLengthExprDto.Read, IlArrayLengthExprDto.Write);
      serializers.Register(IlCallDto.Read, IlCallDto.Write);
      serializers.Register(IlConvExprDto.Read, IlConvExprDto.Write);
      serializers.Register(IlBoxExprDto.Read, IlBoxExprDto.Write);
      serializers.Register(IlUnboxExprDto.Read, IlUnboxExprDto.Write);
      serializers.Register(IlCastClassExprDto.Read, IlCastClassExprDto.Write);
      serializers.Register(IlIsInstExprDto.Read, IlIsInstExprDto.Write);
      serializers.Register(IlManagedRefExprDto.Read, IlManagedRefExprDto.Write);
      serializers.Register(IlUnmanagedRefExprDto.Read, IlUnmanagedRefExprDto.Write);
      serializers.Register(IlManagedDerefExprDto.Read, IlManagedDerefExprDto.Write);
      serializers.Register(IlUnmanagedDerefExprDto.Read, IlUnmanagedDerefExprDto.Write);
      serializers.Register(IlStackAllocExprDto.Read, IlStackAllocExprDto.Write);
      serializers.Register(IlArgListRefDto.Read, IlArgListRefDto.Write);
      serializers.Register(IlCalliDto.Read, IlCalliDto.Write);
      serializers.Register(IlAssignStmtDto.Read, IlAssignStmtDto.Write);
      serializers.Register(IlCallStmtDto.Read, IlCallStmtDto.Write);
      serializers.Register(IlCalliStmtDto.Read, IlCalliStmtDto.Write);
      serializers.Register(IlReturnStmtDto.Read, IlReturnStmtDto.Write);
      serializers.Register(IlThrowStmtDto.Read, IlThrowStmtDto.Write);
      serializers.Register(IlRethrowStmtDto.Read, IlRethrowStmtDto.Write);
      serializers.Register(IlEndFinallyStmtDto.Read, IlEndFinallyStmtDto.Write);
      serializers.Register(IlEndFaultStmtDto.Read, IlEndFaultStmtDto.Write);
      serializers.Register(IlEndFilterStmtDto.Read, IlEndFilterStmtDto.Write);
      serializers.Register(IlGotoStmtDto.Read, IlGotoStmtDto.Write);
      serializers.Register(IlIfStmtDto.Read, IlIfStmtDto.Write);
      serializers.Register(IlArgAccessDto.Read, IlArgAccessDto.Write);
      serializers.Register(IlVarAccessDto.Read, IlVarAccessDto.Write);
      serializers.Register(IlExprDto_Unknown.Read, IlExprDto_Unknown.Write);
      serializers.Register(IlValueDto_Unknown.Read, IlValueDto_Unknown.Write);
      serializers.Register(IlConstDto_Unknown.Read, IlConstDto_Unknown.Write);
      serializers.Register(IlNumConstDto_Unknown.Read, IlNumConstDto_Unknown.Write);
      serializers.Register(IlUnaryOpDto_Unknown.Read, IlUnaryOpDto_Unknown.Write);
      serializers.Register(IlBinaryOpDto_Unknown.Read, IlBinaryOpDto_Unknown.Write);
      serializers.Register(IlCastExprDto_Unknown.Read, IlCastExprDto_Unknown.Write);
      serializers.Register(IlRefExprDto_Unknown.Read, IlRefExprDto_Unknown.Write);
      serializers.Register(IlDerefExprDto_Unknown.Read, IlDerefExprDto_Unknown.Write);
      serializers.Register(IlStmtDto_Unknown.Read, IlStmtDto_Unknown.Write);
      serializers.Register(IlEhStmtDto_Unknown.Read, IlEhStmtDto_Unknown.Write);
      serializers.Register(IlBranchStmtDto_Unknown.Read, IlBranchStmtDto_Unknown.Write);
      
      serializers.RegisterToplevelOnce(typeof(IlRoot), IlRoot.RegisterDeclaredTypesSerializers);
    }
    
    public IlMethodBodyModel(Lifetime lifetime, IProtocol protocol) : this()
    {
      Identify(protocol.Identities, RdId.Root.Mix("IlMethodBodyModel"));
      Bind(lifetime, protocol, "IlMethodBodyModel");
    }
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("IlMethodBodyModel (");
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:80</p>
  /// </summary>
  public sealed class IlAddOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlAddOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlAddOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlAddOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlAddOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlAddOpDto) obj);
    }
    public bool Equals(IlAddOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlAddOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:90</p>
  /// </summary>
  public sealed class IlAndOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlAndOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlAndOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlAndOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlAndOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlAndOpDto) obj);
    }
    public bool Equals(IlAndOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlAndOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:250</p>
  /// </summary>
  public sealed class IlArgAccessDto : IlValueDto
  {
    //fields
    //public fields
    public int Index {get; private set;}
    
    //private fields
    //primary constructor
    public IlArgAccessDto(
      int index,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Index = index;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlArgAccessDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var index = reader.ReadInt();
      var _result = new IlArgAccessDto(index, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlArgAccessDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Index);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlArgAccessDto) obj);
    }
    public bool Equals(IlArgAccessDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Index == other.Index && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Index.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlArgAccessDto (");
      using (printer.IndentCookie()) {
        printer.Print("index = "); Index.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:180</p>
  /// </summary>
  public sealed class IlArgListRefDto : IlExprDto
  {
    //fields
    //public fields
    [NotNull] public InstanceId Method {get; private set;}
    
    //private fields
    //primary constructor
    public IlArgListRefDto(
      [NotNull] InstanceId method,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (method == null) throw new ArgumentNullException("method");
      
      Method = method;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlArgListRefDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var method = InstanceId.Read(ctx, reader);
      var _result = new IlArgListRefDto(method, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlArgListRefDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      InstanceId.Write(ctx, writer, value.Method);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlArgListRefDto) obj);
    }
    public bool Equals(IlArgListRefDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Method, other.Method) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Method.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlArgListRefDto (");
      using (printer.IndentCookie()) {
        printer.Print("method = "); Method.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:125</p>
  /// </summary>
  public sealed class IlArrayAccessDto : IlValueDto
  {
    //fields
    //public fields
    [NotNull] public IlExprDto Array {get; private set;}
    [NotNull] public IlExprDto Index {get; private set;}
    
    //private fields
    //primary constructor
    public IlArrayAccessDto(
      [NotNull] IlExprDto array,
      [NotNull] IlExprDto index,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (array == null) throw new ArgumentNullException("array");
      if (index == null) throw new ArgumentNullException("index");
      
      Array = array;
      Index = index;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlArrayAccessDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var array = IlExprDto.Read(ctx, reader);
      var index = IlExprDto.Read(ctx, reader);
      var _result = new IlArrayAccessDto(array, index, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlArrayAccessDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      IlExprDto.Write(ctx, writer, value.Array);
      IlExprDto.Write(ctx, writer, value.Index);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlArrayAccessDto) obj);
    }
    public bool Equals(IlArrayAccessDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Array, other.Array) && Equals(Index, other.Index) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Array.GetHashCode();
        hash = hash * 31 + Index.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlArrayAccessDto (");
      using (printer.IndentCookie()) {
        printer.Print("array = "); Array.PrintEx(printer); printer.Println();
        printer.Print("index = "); Index.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:53</p>
  /// </summary>
  public sealed class IlArrayConstDto : IlConstDto
  {
    //fields
    //public fields
    [NotNull] public List<IlConstDto> Values {get; private set;}
    
    //private fields
    //primary constructor
    public IlArrayConstDto(
      [NotNull] List<IlConstDto> values,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (values == null) throw new ArgumentNullException("values");
      
      Values = values;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlArrayConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var values = ReadIlConstDtoList(ctx, reader);
      var _result = new IlArrayConstDto(values, type);
      return _result;
    };
    public static CtxReadDelegate<List<IlConstDto>> ReadIlConstDtoList = IlConstDto.Read.List();
    
    public static new CtxWriteDelegate<IlArrayConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      WriteIlConstDtoList(ctx, writer, value.Values);
    };
    public static  CtxWriteDelegate<List<IlConstDto>> WriteIlConstDtoList = IlConstDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlArrayConstDto) obj);
    }
    public bool Equals(IlArrayConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Values.SequenceEqual(other.Values) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Values.ContentHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlArrayConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("values = "); Values.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:135</p>
  /// </summary>
  public sealed class IlArrayLengthExprDto : IlExprDto
  {
    //fields
    //public fields
    [NotNull] public IlExprDto Array {get; private set;}
    
    //private fields
    //primary constructor
    public IlArrayLengthExprDto(
      [NotNull] IlExprDto array,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (array == null) throw new ArgumentNullException("array");
      
      Array = array;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlArrayLengthExprDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var array = IlExprDto.Read(ctx, reader);
      var _result = new IlArrayLengthExprDto(array, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlArrayLengthExprDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      IlExprDto.Write(ctx, writer, value.Array);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlArrayLengthExprDto) obj);
    }
    public bool Equals(IlArrayLengthExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Array, other.Array) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Array.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlArrayLengthExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("array = "); Array.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:196</p>
  /// </summary>
  public sealed class IlAssignStmtDto : IlStmtDto
  {
    //fields
    //public fields
    [NotNull] public IlValueDto Lhv {get; private set;}
    [NotNull] public IlExprDto Rhv {get; private set;}
    
    //private fields
    //primary constructor
    public IlAssignStmtDto(
      [NotNull] IlValueDto lhv,
      [NotNull] IlExprDto rhv,
      [Nullable] int? fileLineIdx
    ) : base (
      fileLineIdx
     ) 
    {
      if (lhv == null) throw new ArgumentNullException("lhv");
      if (rhv == null) throw new ArgumentNullException("rhv");
      
      Lhv = lhv;
      Rhv = rhv;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlAssignStmtDto> Read = (ctx, reader) => 
    {
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var lhv = IlValueDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var _result = new IlAssignStmtDto(lhv, rhv, fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlAssignStmtDto> Write = (ctx, writer, value) => 
    {
      WriteIntNullable(ctx, writer, value.FileLineIdx);
      IlValueDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlAssignStmtDto) obj);
    }
    public bool Equals(IlAssignStmtDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlAssignStmtDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:73</p>
  /// </summary>
  public abstract class IlBinaryOpDto : IlExprDto
  {
    //fields
    //public fields
    [NotNull] public IlExprDto Lhv {get; private set;}
    [NotNull] public IlExprDto Rhv {get; private set;}
    public bool IsChecked {get; private set;}
    public bool IsUnsigned {get; private set;}
    
    //private fields
    //primary constructor
    protected IlBinaryOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (lhv == null) throw new ArgumentNullException("lhv");
      if (rhv == null) throw new ArgumentNullException("rhv");
      
      Lhv = lhv;
      Rhv = rhv;
      IsChecked = isChecked;
      IsUnsigned = isUnsigned;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlBinaryOpDto> Read = Polymorphic<IlBinaryOpDto>.ReadAbstract(IlBinaryOpDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlBinaryOpDto> Write = Polymorphic<IlBinaryOpDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlBinaryOpDto_Unknown : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlBinaryOpDto_Unknown(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlBinaryOpDto_Unknown> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlBinaryOpDto_Unknown(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlBinaryOpDto_Unknown> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlBinaryOpDto_Unknown) obj);
    }
    public bool Equals(IlBinaryOpDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlBinaryOpDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:62</p>
  /// </summary>
  public sealed class IlBoolConstDto : IlConstDto
  {
    //fields
    //public fields
    public bool Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlBoolConstDto(
      bool value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlBoolConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var value = reader.ReadBool();
      var _result = new IlBoolConstDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlBoolConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlBoolConstDto) obj);
    }
    public bool Equals(IlBoolConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Value == other.Value && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlBoolConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:149</p>
  /// </summary>
  public sealed class IlBoxExprDto : IlCastExprDto
  {
    //fields
    //public fields
    [NotNull] public TypeId BoxedType {get; private set;}
    
    //private fields
    //primary constructor
    public IlBoxExprDto(
      [NotNull] TypeId boxedType,
      [NotNull] TypeId targetType,
      [NotNull] IlExprDto operand,
      [NotNull] TypeId type
    ) : base (
      targetType,
      operand,
      type
     ) 
    {
      if (boxedType == null) throw new ArgumentNullException("boxedType");
      
      BoxedType = boxedType;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlBoxExprDto> Read = (ctx, reader) => 
    {
      var targetType = TypeId.Read(ctx, reader);
      var operand = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var boxedType = TypeId.Read(ctx, reader);
      var _result = new IlBoxExprDto(boxedType, targetType, operand, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlBoxExprDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.TargetType);
      IlExprDto.Write(ctx, writer, value.Operand);
      TypeId.Write(ctx, writer, value.Type);
      TypeId.Write(ctx, writer, value.BoxedType);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlBoxExprDto) obj);
    }
    public bool Equals(IlBoxExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(BoxedType, other.BoxedType) && Equals(TargetType, other.TargetType) && Equals(Operand, other.Operand) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + BoxedType.GetHashCode();
        hash = hash * 31 + TargetType.GetHashCode();
        hash = hash * 31 + Operand.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlBoxExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("boxedType = "); BoxedType.PrintEx(printer); printer.Println();
        printer.Print("targetType = "); TargetType.PrintEx(printer); printer.Println();
        printer.Print("operand = "); Operand.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:234</p>
  /// </summary>
  public abstract class IlBranchStmtDto : IlStmtDto
  {
    //fields
    //public fields
    public int Target {get; private set;}
    
    //private fields
    //primary constructor
    protected IlBranchStmtDto(
      int target,
      [Nullable] int? fileLineIdx
    ) : base (
      fileLineIdx
     ) 
    {
      Target = target;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlBranchStmtDto> Read = Polymorphic<IlBranchStmtDto>.ReadAbstract(IlBranchStmtDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlBranchStmtDto> Write = Polymorphic<IlBranchStmtDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlBranchStmtDto_Unknown : IlBranchStmtDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlBranchStmtDto_Unknown(
      int target,
      [Nullable] int? fileLineIdx
    ) : base (
      target,
      fileLineIdx
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlBranchStmtDto_Unknown> Read = (ctx, reader) => 
    {
      var target = reader.ReadInt();
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var _result = new IlBranchStmtDto_Unknown(target, fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlBranchStmtDto_Unknown> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Target);
      WriteIntNullable(ctx, writer, value.FileLineIdx);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlBranchStmtDto_Unknown) obj);
    }
    public bool Equals(IlBranchStmtDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Target == other.Target && Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Target.GetHashCode();
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlBranchStmtDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("target = "); Target.PrintEx(printer); printer.Println();
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:137</p>
  /// </summary>
  public sealed class IlCallDto : IlExprDto
  {
    //fields
    //public fields
    [NotNull] public InstanceId Method {get; private set;}
    [NotNull] public List<IlExprDto> Args {get; private set;}
    
    //private fields
    //primary constructor
    public IlCallDto(
      [NotNull] InstanceId method,
      [NotNull] List<IlExprDto> args,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (method == null) throw new ArgumentNullException("method");
      if (args == null) throw new ArgumentNullException("args");
      
      Method = method;
      Args = args;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCallDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var method = InstanceId.Read(ctx, reader);
      var args = ReadIlExprDtoList(ctx, reader);
      var _result = new IlCallDto(method, args, type);
      return _result;
    };
    public static CtxReadDelegate<List<IlExprDto>> ReadIlExprDtoList = IlExprDto.Read.List();
    
    public static new CtxWriteDelegate<IlCallDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      InstanceId.Write(ctx, writer, value.Method);
      WriteIlExprDtoList(ctx, writer, value.Args);
    };
    public static  CtxWriteDelegate<List<IlExprDto>> WriteIlExprDtoList = IlExprDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCallDto) obj);
    }
    public bool Equals(IlCallDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Method, other.Method) && Args.SequenceEqual(other.Args) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Method.GetHashCode();
        hash = hash * 31 + Args.ContentHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCallDto (");
      using (printer.IndentCookie()) {
        printer.Print("method = "); Method.PrintEx(printer); printer.Println();
        printer.Print("args = "); Args.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:202</p>
  /// </summary>
  public sealed class IlCallStmtDto : IlStmtDto
  {
    //fields
    //public fields
    [NotNull] public IlCallDto Call {get; private set;}
    
    //private fields
    //primary constructor
    public IlCallStmtDto(
      [NotNull] IlCallDto call,
      [Nullable] int? fileLineIdx
    ) : base (
      fileLineIdx
     ) 
    {
      if (call == null) throw new ArgumentNullException("call");
      
      Call = call;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCallStmtDto> Read = (ctx, reader) => 
    {
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var call = IlCallDto.Read(ctx, reader);
      var _result = new IlCallStmtDto(call, fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlCallStmtDto> Write = (ctx, writer, value) => 
    {
      WriteIntNullable(ctx, writer, value.FileLineIdx);
      IlCallDto.Write(ctx, writer, value.Call);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCallStmtDto) obj);
    }
    public bool Equals(IlCallStmtDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Call, other.Call) && Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Call.GetHashCode();
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCallStmtDto (");
      using (printer.IndentCookie()) {
        printer.Print("call = "); Call.PrintEx(printer); printer.Println();
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:184</p>
  /// </summary>
  public sealed class IlCalliDto : IlExprDto
  {
    //fields
    //public fields
    [NotNull] public IlSignatureDto Signature {get; private set;}
    [NotNull] public IlExprDto Ftn {get; private set;}
    [NotNull] public List<IlExprDto> Args {get; private set;}
    
    //private fields
    //primary constructor
    public IlCalliDto(
      [NotNull] IlSignatureDto signature,
      [NotNull] IlExprDto ftn,
      [NotNull] List<IlExprDto> args,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (signature == null) throw new ArgumentNullException("signature");
      if (ftn == null) throw new ArgumentNullException("ftn");
      if (args == null) throw new ArgumentNullException("args");
      
      Signature = signature;
      Ftn = ftn;
      Args = args;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCalliDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var signature = IlSignatureDto.Read(ctx, reader);
      var ftn = IlExprDto.Read(ctx, reader);
      var args = ReadIlExprDtoList(ctx, reader);
      var _result = new IlCalliDto(signature, ftn, args, type);
      return _result;
    };
    public static CtxReadDelegate<List<IlExprDto>> ReadIlExprDtoList = IlExprDto.Read.List();
    
    public static new CtxWriteDelegate<IlCalliDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      IlSignatureDto.Write(ctx, writer, value.Signature);
      IlExprDto.Write(ctx, writer, value.Ftn);
      WriteIlExprDtoList(ctx, writer, value.Args);
    };
    public static  CtxWriteDelegate<List<IlExprDto>> WriteIlExprDtoList = IlExprDto.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCalliDto) obj);
    }
    public bool Equals(IlCalliDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Signature, other.Signature) && Equals(Ftn, other.Ftn) && Args.SequenceEqual(other.Args) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Signature.GetHashCode();
        hash = hash * 31 + Ftn.GetHashCode();
        hash = hash * 31 + Args.ContentHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCalliDto (");
      using (printer.IndentCookie()) {
        printer.Print("signature = "); Signature.PrintEx(printer); printer.Println();
        printer.Print("ftn = "); Ftn.PrintEx(printer); printer.Println();
        printer.Print("args = "); Args.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:206</p>
  /// </summary>
  public sealed class IlCalliStmtDto : IlStmtDto
  {
    //fields
    //public fields
    [NotNull] public IlCalliDto Calli {get; private set;}
    
    //private fields
    //primary constructor
    public IlCalliStmtDto(
      [NotNull] IlCalliDto calli,
      [Nullable] int? fileLineIdx
    ) : base (
      fileLineIdx
     ) 
    {
      if (calli == null) throw new ArgumentNullException("calli");
      
      Calli = calli;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCalliStmtDto> Read = (ctx, reader) => 
    {
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var calli = IlCalliDto.Read(ctx, reader);
      var _result = new IlCalliStmtDto(calli, fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlCalliStmtDto> Write = (ctx, writer, value) => 
    {
      WriteIntNullable(ctx, writer, value.FileLineIdx);
      IlCalliDto.Write(ctx, writer, value.Calli);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCalliStmtDto) obj);
    }
    public bool Equals(IlCalliStmtDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Calli, other.Calli) && Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Calli.GetHashCode();
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCalliStmtDto (");
      using (printer.IndentCookie()) {
        printer.Print("calli = "); Calli.PrintEx(printer); printer.Println();
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:155</p>
  /// </summary>
  public sealed class IlCastClassExprDto : IlCastExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlCastClassExprDto(
      [NotNull] TypeId targetType,
      [NotNull] IlExprDto operand,
      [NotNull] TypeId type
    ) : base (
      targetType,
      operand,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCastClassExprDto> Read = (ctx, reader) => 
    {
      var targetType = TypeId.Read(ctx, reader);
      var operand = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlCastClassExprDto(targetType, operand, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlCastClassExprDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.TargetType);
      IlExprDto.Write(ctx, writer, value.Operand);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCastClassExprDto) obj);
    }
    public bool Equals(IlCastClassExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(TargetType, other.TargetType) && Equals(Operand, other.Operand) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TargetType.GetHashCode();
        hash = hash * 31 + Operand.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCastClassExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("targetType = "); TargetType.PrintEx(printer); printer.Println();
        printer.Print("operand = "); Operand.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:142</p>
  /// </summary>
  public abstract class IlCastExprDto : IlExprDto
  {
    //fields
    //public fields
    [NotNull] public TypeId TargetType {get; private set;}
    [NotNull] public IlExprDto Operand {get; private set;}
    
    //private fields
    //primary constructor
    protected IlCastExprDto(
      [NotNull] TypeId targetType,
      [NotNull] IlExprDto operand,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (targetType == null) throw new ArgumentNullException("targetType");
      if (operand == null) throw new ArgumentNullException("operand");
      
      TargetType = targetType;
      Operand = operand;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCastExprDto> Read = Polymorphic<IlCastExprDto>.ReadAbstract(IlCastExprDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlCastExprDto> Write = Polymorphic<IlCastExprDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlCastExprDto_Unknown : IlCastExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlCastExprDto_Unknown(
      [NotNull] TypeId targetType,
      [NotNull] IlExprDto operand,
      [NotNull] TypeId type
    ) : base (
      targetType,
      operand,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCastExprDto_Unknown> Read = (ctx, reader) => 
    {
      var targetType = TypeId.Read(ctx, reader);
      var operand = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlCastExprDto_Unknown(targetType, operand, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlCastExprDto_Unknown> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.TargetType);
      IlExprDto.Write(ctx, writer, value.Operand);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCastExprDto_Unknown) obj);
    }
    public bool Equals(IlCastExprDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(TargetType, other.TargetType) && Equals(Operand, other.Operand) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TargetType.GetHashCode();
        hash = hash * 31 + Operand.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCastExprDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("targetType = "); TargetType.PrintEx(printer); printer.Println();
        printer.Print("operand = "); Operand.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:100</p>
  /// </summary>
  public sealed class IlCeqOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlCeqOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCeqOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlCeqOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlCeqOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCeqOpDto) obj);
    }
    public bool Equals(IlCeqOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCeqOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:106</p>
  /// </summary>
  public sealed class IlCgeOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlCgeOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCgeOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlCgeOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlCgeOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCgeOpDto) obj);
    }
    public bool Equals(IlCgeOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCgeOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:104</p>
  /// </summary>
  public sealed class IlCgtOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlCgtOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCgtOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlCgtOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlCgtOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCgtOpDto) obj);
    }
    public bool Equals(IlCgtOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCgtOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:51</p>
  /// </summary>
  public sealed class IlCharConstDto : IlNumConstDto
  {
    //fields
    //public fields
    public char Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlCharConstDto(
      char value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCharConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var value = reader.ReadChar();
      var _result = new IlCharConstDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlCharConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCharConstDto) obj);
    }
    public bool Equals(IlCharConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Value == other.Value && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCharConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:110</p>
  /// </summary>
  public sealed class IlCleOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlCleOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCleOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlCleOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlCleOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCleOpDto) obj);
    }
    public bool Equals(IlCleOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCleOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:108</p>
  /// </summary>
  public sealed class IlCltOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlCltOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCltOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlCltOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlCltOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCltOpDto) obj);
    }
    public bool Equals(IlCltOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCltOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:102</p>
  /// </summary>
  public sealed class IlCneOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlCneOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlCneOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlCneOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlCneOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlCneOpDto) obj);
    }
    public bool Equals(IlCneOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlCneOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:33</p>
  /// </summary>
  public abstract class IlConstDto : IlValueDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    protected IlConstDto(
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlConstDto> Read = Polymorphic<IlConstDto>.ReadAbstract(IlConstDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlConstDto> Write = Polymorphic<IlConstDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlConstDto_Unknown : IlConstDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlConstDto_Unknown(
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlConstDto_Unknown> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var _result = new IlConstDto_Unknown(type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlConstDto_Unknown> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlConstDto_Unknown) obj);
    }
    public bool Equals(IlConstDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlConstDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:147</p>
  /// </summary>
  public sealed class IlConvExprDto : IlCastExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlConvExprDto(
      [NotNull] TypeId targetType,
      [NotNull] IlExprDto operand,
      [NotNull] TypeId type
    ) : base (
      targetType,
      operand,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlConvExprDto> Read = (ctx, reader) => 
    {
      var targetType = TypeId.Read(ctx, reader);
      var operand = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlConvExprDto(targetType, operand, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlConvExprDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.TargetType);
      IlExprDto.Write(ctx, writer, value.Operand);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlConvExprDto) obj);
    }
    public bool Equals(IlConvExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(TargetType, other.TargetType) && Equals(Operand, other.Operand) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TargetType.GetHashCode();
        hash = hash * 31 + Operand.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlConvExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("targetType = "); TargetType.PrintEx(printer); printer.Println();
        printer.Print("operand = "); Operand.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:164</p>
  /// </summary>
  public abstract class IlDerefExprDto : IlValueDto
  {
    //fields
    //public fields
    [NotNull] public IlExprDto Value {get; private set;}
    
    //private fields
    //primary constructor
    protected IlDerefExprDto(
      [NotNull] IlExprDto value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (value == null) throw new ArgumentNullException("value");
      
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlDerefExprDto> Read = Polymorphic<IlDerefExprDto>.ReadAbstract(IlDerefExprDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlDerefExprDto> Write = Polymorphic<IlDerefExprDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlDerefExprDto_Unknown : IlDerefExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlDerefExprDto_Unknown(
      [NotNull] IlExprDto value,
      [NotNull] TypeId type
    ) : base (
      value,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlDerefExprDto_Unknown> Read = (ctx, reader) => 
    {
      var value = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlDerefExprDto_Unknown(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlDerefExprDto_Unknown> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Value);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlDerefExprDto_Unknown) obj);
    }
    public bool Equals(IlDerefExprDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Value, other.Value) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlDerefExprDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:86</p>
  /// </summary>
  public sealed class IlDivOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlDivOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlDivOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlDivOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlDivOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlDivOpDto) obj);
    }
    public bool Equals(IlDivOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlDivOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:49</p>
  /// </summary>
  public sealed class IlDoubleConstDto : IlNumConstDto
  {
    //fields
    //public fields
    public double Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlDoubleConstDto(
      double value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlDoubleConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var value = reader.ReadDouble();
      var _result = new IlDoubleConstDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlDoubleConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlDoubleConstDto) obj);
    }
    public bool Equals(IlDoubleConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Value == other.Value && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlDoubleConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:215</p>
  /// </summary>
  public abstract class IlEhStmtDto : IlStmtDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    protected IlEhStmtDto(
      [Nullable] int? fileLineIdx
    ) : base (
      fileLineIdx
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlEhStmtDto> Read = Polymorphic<IlEhStmtDto>.ReadAbstract(IlEhStmtDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlEhStmtDto> Write = Polymorphic<IlEhStmtDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlEhStmtDto_Unknown : IlEhStmtDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlEhStmtDto_Unknown(
      [Nullable] int? fileLineIdx
    ) : base (
      fileLineIdx
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlEhStmtDto_Unknown> Read = (ctx, reader) => 
    {
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var _result = new IlEhStmtDto_Unknown(fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlEhStmtDto_Unknown> Write = (ctx, writer, value) => 
    {
      WriteIntNullable(ctx, writer, value.FileLineIdx);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlEhStmtDto_Unknown) obj);
    }
    public bool Equals(IlEhStmtDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlEhStmtDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:226</p>
  /// </summary>
  public sealed class IlEndFaultStmtDto : IlEhStmtDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlEndFaultStmtDto(
      [Nullable] int? fileLineIdx
    ) : base (
      fileLineIdx
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlEndFaultStmtDto> Read = (ctx, reader) => 
    {
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var _result = new IlEndFaultStmtDto(fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlEndFaultStmtDto> Write = (ctx, writer, value) => 
    {
      WriteIntNullable(ctx, writer, value.FileLineIdx);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlEndFaultStmtDto) obj);
    }
    public bool Equals(IlEndFaultStmtDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlEndFaultStmtDto (");
      using (printer.IndentCookie()) {
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:229</p>
  /// </summary>
  public sealed class IlEndFilterStmtDto : IlEhStmtDto
  {
    //fields
    //public fields
    [NotNull] public IlExprDto Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlEndFilterStmtDto(
      [NotNull] IlExprDto value,
      [Nullable] int? fileLineIdx
    ) : base (
      fileLineIdx
     ) 
    {
      if (value == null) throw new ArgumentNullException("value");
      
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlEndFilterStmtDto> Read = (ctx, reader) => 
    {
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var value = IlExprDto.Read(ctx, reader);
      var _result = new IlEndFilterStmtDto(value, fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlEndFilterStmtDto> Write = (ctx, writer, value) => 
    {
      WriteIntNullable(ctx, writer, value.FileLineIdx);
      IlExprDto.Write(ctx, writer, value.Value);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlEndFilterStmtDto) obj);
    }
    public bool Equals(IlEndFilterStmtDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Value, other.Value) && Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlEndFilterStmtDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:223</p>
  /// </summary>
  public sealed class IlEndFinallyStmtDto : IlEhStmtDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlEndFinallyStmtDto(
      [Nullable] int? fileLineIdx
    ) : base (
      fileLineIdx
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlEndFinallyStmtDto> Read = (ctx, reader) => 
    {
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var _result = new IlEndFinallyStmtDto(fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlEndFinallyStmtDto> Write = (ctx, writer, value) => 
    {
      WriteIntNullable(ctx, writer, value.FileLineIdx);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlEndFinallyStmtDto) obj);
    }
    public bool Equals(IlEndFinallyStmtDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlEndFinallyStmtDto (");
      using (printer.IndentCookie()) {
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:56</p>
  /// </summary>
  public sealed class IlEnumConstDto : IlConstDto
  {
    //fields
    //public fields
    [NotNull] public TypeId UnderlyingType {get; private set;}
    [NotNull] public IlConstDto UnderlyingValue {get; private set;}
    
    //private fields
    //primary constructor
    public IlEnumConstDto(
      [NotNull] TypeId underlyingType,
      [NotNull] IlConstDto underlyingValue,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (underlyingType == null) throw new ArgumentNullException("underlyingType");
      if (underlyingValue == null) throw new ArgumentNullException("underlyingValue");
      
      UnderlyingType = underlyingType;
      UnderlyingValue = underlyingValue;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlEnumConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var underlyingType = TypeId.Read(ctx, reader);
      var underlyingValue = IlConstDto.Read(ctx, reader);
      var _result = new IlEnumConstDto(underlyingType, underlyingValue, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlEnumConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      TypeId.Write(ctx, writer, value.UnderlyingType);
      IlConstDto.Write(ctx, writer, value.UnderlyingValue);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlEnumConstDto) obj);
    }
    public bool Equals(IlEnumConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(UnderlyingType, other.UnderlyingType) && Equals(UnderlyingValue, other.UnderlyingValue) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + UnderlyingType.GetHashCode();
        hash = hash * 31 + UnderlyingValue.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlEnumConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("underlyingType = "); UnderlyingType.PrintEx(printer); printer.Println();
        printer.Print("underlyingValue = "); UnderlyingValue.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:29</p>
  /// </summary>
  public abstract class IlExprDto{
    //fields
    //public fields
    [NotNull] public TypeId Type {get; private set;}
    
    //private fields
    //primary constructor
    protected IlExprDto(
      [NotNull] TypeId type
    )
    {
      if (type == null) throw new ArgumentNullException("type");
      
      Type = type;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<IlExprDto> Read = Polymorphic<IlExprDto>.ReadAbstract(IlExprDto_Unknown.Read);
    
    public static CtxWriteDelegate<IlExprDto> Write = Polymorphic<IlExprDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlExprDto_Unknown : IlExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlExprDto_Unknown(
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlExprDto_Unknown> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var _result = new IlExprDto_Unknown(type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlExprDto_Unknown> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlExprDto_Unknown) obj);
    }
    public bool Equals(IlExprDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlExprDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:120</p>
  /// </summary>
  public sealed class IlFieldAccessDto : IlValueDto
  {
    //fields
    //public fields
    [Nullable] public IlExprDto Instance {get; private set;}
    [NotNull] public InstanceId Field {get; private set;}
    
    //private fields
    //primary constructor
    public IlFieldAccessDto(
      [Nullable] IlExprDto instance,
      [NotNull] InstanceId field,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (field == null) throw new ArgumentNullException("field");
      
      Instance = instance;
      Field = field;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlFieldAccessDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var instance = ReadIlExprDtoNullable(ctx, reader);
      var field = InstanceId.Read(ctx, reader);
      var _result = new IlFieldAccessDto(instance, field, type);
      return _result;
    };
    public static CtxReadDelegate<IlExprDto> ReadIlExprDtoNullable = IlExprDto.Read.NullableClass();
    
    public static new CtxWriteDelegate<IlFieldAccessDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      WriteIlExprDtoNullable(ctx, writer, value.Instance);
      InstanceId.Write(ctx, writer, value.Field);
    };
    public static  CtxWriteDelegate<IlExprDto> WriteIlExprDtoNullable = IlExprDto.Write.NullableClass();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlFieldAccessDto) obj);
    }
    public bool Equals(IlFieldAccessDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Instance, other.Instance) && Equals(Field, other.Field) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + (Instance != null ? Instance.GetHashCode() : 0);
        hash = hash * 31 + Field.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlFieldAccessDto (");
      using (printer.IndentCookie()) {
        printer.Print("instance = "); Instance.PrintEx(printer); printer.Println();
        printer.Print("field = "); Field.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:67</p>
  /// </summary>
  public sealed class IlFieldRefDto : IlConstDto
  {
    //fields
    //public fields
    [NotNull] public InstanceId Field {get; private set;}
    
    //private fields
    //primary constructor
    public IlFieldRefDto(
      [NotNull] InstanceId field,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (field == null) throw new ArgumentNullException("field");
      
      Field = field;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlFieldRefDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var field = InstanceId.Read(ctx, reader);
      var _result = new IlFieldRefDto(field, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlFieldRefDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      InstanceId.Write(ctx, writer, value.Field);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlFieldRefDto) obj);
    }
    public bool Equals(IlFieldRefDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Field, other.Field) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Field.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlFieldRefDto (");
      using (printer.IndentCookie()) {
        printer.Print("field = "); Field.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:48</p>
  /// </summary>
  public sealed class IlFloatConstDto : IlNumConstDto
  {
    //fields
    //public fields
    public float Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlFloatConstDto(
      float value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlFloatConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var value = reader.ReadFloat();
      var _result = new IlFloatConstDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlFloatConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlFloatConstDto) obj);
    }
    public bool Equals(IlFloatConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Value == other.Value && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlFloatConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:238</p>
  /// </summary>
  public sealed class IlGotoStmtDto : IlBranchStmtDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlGotoStmtDto(
      int target,
      [Nullable] int? fileLineIdx
    ) : base (
      target,
      fileLineIdx
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlGotoStmtDto> Read = (ctx, reader) => 
    {
      var target = reader.ReadInt();
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var _result = new IlGotoStmtDto(target, fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlGotoStmtDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Target);
      WriteIntNullable(ctx, writer, value.FileLineIdx);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlGotoStmtDto) obj);
    }
    public bool Equals(IlGotoStmtDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Target == other.Target && Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Target.GetHashCode();
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlGotoStmtDto (");
      using (printer.IndentCookie()) {
        printer.Print("target = "); Target.PrintEx(printer); printer.Println();
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:241</p>
  /// </summary>
  public sealed class IlIfStmtDto : IlBranchStmtDto
  {
    //fields
    //public fields
    [NotNull] public IlExprDto Cond {get; private set;}
    
    //private fields
    //primary constructor
    public IlIfStmtDto(
      [NotNull] IlExprDto cond,
      int target,
      [Nullable] int? fileLineIdx
    ) : base (
      target,
      fileLineIdx
     ) 
    {
      if (cond == null) throw new ArgumentNullException("cond");
      
      Cond = cond;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlIfStmtDto> Read = (ctx, reader) => 
    {
      var target = reader.ReadInt();
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var cond = IlExprDto.Read(ctx, reader);
      var _result = new IlIfStmtDto(cond, target, fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlIfStmtDto> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Target);
      WriteIntNullable(ctx, writer, value.FileLineIdx);
      IlExprDto.Write(ctx, writer, value.Cond);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlIfStmtDto) obj);
    }
    public bool Equals(IlIfStmtDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Cond, other.Cond) && Target == other.Target && Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Cond.GetHashCode();
        hash = hash * 31 + Target.GetHashCode();
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlIfStmtDto (");
      using (printer.IndentCookie()) {
        printer.Print("cond = "); Cond.PrintEx(printer); printer.Println();
        printer.Print("target = "); Target.PrintEx(printer); printer.Println();
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:39</p>
  /// </summary>
  public sealed class IlInt16ConstDto : IlNumConstDto
  {
    //fields
    //public fields
    public short Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlInt16ConstDto(
      short value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlInt16ConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var value = reader.ReadShort();
      var _result = new IlInt16ConstDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlInt16ConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlInt16ConstDto) obj);
    }
    public bool Equals(IlInt16ConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Value == other.Value && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlInt16ConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:42</p>
  /// </summary>
  public sealed class IlInt32ConstDto : IlNumConstDto
  {
    //fields
    //public fields
    public int Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlInt32ConstDto(
      int value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlInt32ConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var value = reader.ReadInt();
      var _result = new IlInt32ConstDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlInt32ConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlInt32ConstDto) obj);
    }
    public bool Equals(IlInt32ConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Value == other.Value && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlInt32ConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:45</p>
  /// </summary>
  public sealed class IlInt64ConstDto : IlNumConstDto
  {
    //fields
    //public fields
    public long Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlInt64ConstDto(
      long value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlInt64ConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var value = reader.ReadLong();
      var _result = new IlInt64ConstDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlInt64ConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlInt64ConstDto) obj);
    }
    public bool Equals(IlInt64ConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Value == other.Value && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlInt64ConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:36</p>
  /// </summary>
  public sealed class IlInt8ConstDto : IlNumConstDto
  {
    //fields
    //public fields
    public byte Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlInt8ConstDto(
      byte value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlInt8ConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var value = reader.ReadByte();
      var _result = new IlInt8ConstDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlInt8ConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlInt8ConstDto) obj);
    }
    public bool Equals(IlInt8ConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Value == other.Value && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlInt8ConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:157</p>
  /// </summary>
  public sealed class IlIsInstExprDto : IlCastExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlIsInstExprDto(
      [NotNull] TypeId targetType,
      [NotNull] IlExprDto operand,
      [NotNull] TypeId type
    ) : base (
      targetType,
      operand,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlIsInstExprDto> Read = (ctx, reader) => 
    {
      var targetType = TypeId.Read(ctx, reader);
      var operand = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlIsInstExprDto(targetType, operand, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlIsInstExprDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.TargetType);
      IlExprDto.Write(ctx, writer, value.Operand);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlIsInstExprDto) obj);
    }
    public bool Equals(IlIsInstExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(TargetType, other.TargetType) && Equals(Operand, other.Operand) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TargetType.GetHashCode();
        hash = hash * 31 + Operand.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlIsInstExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("targetType = "); TargetType.PrintEx(printer); printer.Println();
        printer.Print("operand = "); Operand.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:172</p>
  /// </summary>
  public sealed class IlManagedDerefExprDto : IlDerefExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlManagedDerefExprDto(
      [NotNull] IlExprDto value,
      [NotNull] TypeId type
    ) : base (
      value,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlManagedDerefExprDto> Read = (ctx, reader) => 
    {
      var value = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlManagedDerefExprDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlManagedDerefExprDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Value);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlManagedDerefExprDto) obj);
    }
    public bool Equals(IlManagedDerefExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Value, other.Value) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlManagedDerefExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:168</p>
  /// </summary>
  public sealed class IlManagedRefExprDto : IlRefExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlManagedRefExprDto(
      [NotNull] IlExprDto value,
      [NotNull] TypeId type
    ) : base (
      value,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlManagedRefExprDto> Read = (ctx, reader) => 
    {
      var value = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlManagedRefExprDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlManagedRefExprDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Value);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlManagedRefExprDto) obj);
    }
    public bool Equals(IlManagedRefExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Value, other.Value) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlManagedRefExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:66</p>
  /// </summary>
  public sealed class IlMethodRefDto : IlConstDto
  {
    //fields
    //public fields
    [NotNull] public InstanceId Method {get; private set;}
    
    //private fields
    //primary constructor
    public IlMethodRefDto(
      [NotNull] InstanceId method,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (method == null) throw new ArgumentNullException("method");
      
      Method = method;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlMethodRefDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var method = InstanceId.Read(ctx, reader);
      var _result = new IlMethodRefDto(method, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlMethodRefDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      InstanceId.Write(ctx, writer, value.Method);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlMethodRefDto) obj);
    }
    public bool Equals(IlMethodRefDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Method, other.Method) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Method.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlMethodRefDto (");
      using (printer.IndentCookie()) {
        printer.Print("method = "); Method.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:84</p>
  /// </summary>
  public sealed class IlMulOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlMulOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlMulOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlMulOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlMulOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlMulOpDto) obj);
    }
    public bool Equals(IlMulOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlMulOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:70</p>
  /// </summary>
  public sealed class IlNegOpDto : IlUnaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlNegOpDto(
      [NotNull] IlExprDto operand,
      [NotNull] TypeId type
    ) : base (
      operand,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlNegOpDto> Read = (ctx, reader) => 
    {
      var operand = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlNegOpDto(operand, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlNegOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Operand);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlNegOpDto) obj);
    }
    public bool Equals(IlNegOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Operand, other.Operand) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Operand.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlNegOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("operand = "); Operand.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:130</p>
  /// </summary>
  public sealed class IlNewArrayExprDto : IlExprDto
  {
    //fields
    //public fields
    [NotNull] public TypeId ElementType {get; private set;}
    [NotNull] public IlExprDto Size {get; private set;}
    
    //private fields
    //primary constructor
    public IlNewArrayExprDto(
      [NotNull] TypeId elementType,
      [NotNull] IlExprDto size,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (elementType == null) throw new ArgumentNullException("elementType");
      if (size == null) throw new ArgumentNullException("size");
      
      ElementType = elementType;
      Size = size;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlNewArrayExprDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var elementType = TypeId.Read(ctx, reader);
      var size = IlExprDto.Read(ctx, reader);
      var _result = new IlNewArrayExprDto(elementType, size, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlNewArrayExprDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      TypeId.Write(ctx, writer, value.ElementType);
      IlExprDto.Write(ctx, writer, value.Size);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlNewArrayExprDto) obj);
    }
    public bool Equals(IlNewArrayExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(ElementType, other.ElementType) && Equals(Size, other.Size) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + ElementType.GetHashCode();
        hash = hash * 31 + Size.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlNewArrayExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("elementType = "); ElementType.PrintEx(printer); printer.Println();
        printer.Print("size = "); Size.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:112</p>
  /// </summary>
  public sealed class IlNewExprDto : IlExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlNewExprDto(
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlNewExprDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var _result = new IlNewExprDto(type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlNewExprDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlNewExprDto) obj);
    }
    public bool Equals(IlNewExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlNewExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:71</p>
  /// </summary>
  public sealed class IlNotOpDto : IlUnaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlNotOpDto(
      [NotNull] IlExprDto operand,
      [NotNull] TypeId type
    ) : base (
      operand,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlNotOpDto> Read = (ctx, reader) => 
    {
      var operand = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlNotOpDto(operand, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlNotOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Operand);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlNotOpDto) obj);
    }
    public bool Equals(IlNotOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Operand, other.Operand) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Operand.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlNotOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("operand = "); Operand.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:61</p>
  /// </summary>
  public sealed class IlNullDto : IlConstDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlNullDto(
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlNullDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var _result = new IlNullDto(type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlNullDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlNullDto) obj);
    }
    public bool Equals(IlNullDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlNullDto (");
      using (printer.IndentCookie()) {
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:34</p>
  /// </summary>
  public abstract class IlNumConstDto : IlConstDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    protected IlNumConstDto(
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlNumConstDto> Read = Polymorphic<IlNumConstDto>.ReadAbstract(IlNumConstDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlNumConstDto> Write = Polymorphic<IlNumConstDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlNumConstDto_Unknown : IlNumConstDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlNumConstDto_Unknown(
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlNumConstDto_Unknown> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var _result = new IlNumConstDto_Unknown(type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlNumConstDto_Unknown> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlNumConstDto_Unknown) obj);
    }
    public bool Equals(IlNumConstDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlNumConstDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:92</p>
  /// </summary>
  public sealed class IlOrOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlOrOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlOrOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlOrOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlOrOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlOrOpDto) obj);
    }
    public bool Equals(IlOrOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlOrOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:160</p>
  /// </summary>
  public abstract class IlRefExprDto : IlValueDto
  {
    //fields
    //public fields
    [NotNull] public IlExprDto Value {get; private set;}
    
    //private fields
    //primary constructor
    protected IlRefExprDto(
      [NotNull] IlExprDto value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (value == null) throw new ArgumentNullException("value");
      
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlRefExprDto> Read = Polymorphic<IlRefExprDto>.ReadAbstract(IlRefExprDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlRefExprDto> Write = Polymorphic<IlRefExprDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlRefExprDto_Unknown : IlRefExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlRefExprDto_Unknown(
      [NotNull] IlExprDto value,
      [NotNull] TypeId type
    ) : base (
      value,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlRefExprDto_Unknown> Read = (ctx, reader) => 
    {
      var value = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlRefExprDto_Unknown(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlRefExprDto_Unknown> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Value);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlRefExprDto_Unknown) obj);
    }
    public bool Equals(IlRefExprDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Value, other.Value) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlRefExprDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:88</p>
  /// </summary>
  public sealed class IlRemOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlRemOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlRemOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlRemOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlRemOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlRemOpDto) obj);
    }
    public bool Equals(IlRemOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlRemOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:220</p>
  /// </summary>
  public sealed class IlRethrowStmtDto : IlEhStmtDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlRethrowStmtDto(
      [Nullable] int? fileLineIdx
    ) : base (
      fileLineIdx
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlRethrowStmtDto> Read = (ctx, reader) => 
    {
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var _result = new IlRethrowStmtDto(fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlRethrowStmtDto> Write = (ctx, writer, value) => 
    {
      WriteIntNullable(ctx, writer, value.FileLineIdx);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlRethrowStmtDto) obj);
    }
    public bool Equals(IlRethrowStmtDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlRethrowStmtDto (");
      using (printer.IndentCookie()) {
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:210</p>
  /// </summary>
  public sealed class IlReturnStmtDto : IlStmtDto
  {
    //fields
    //public fields
    [Nullable] public IlExprDto RetVal {get; private set;}
    
    //private fields
    //primary constructor
    public IlReturnStmtDto(
      [Nullable] IlExprDto retVal,
      [Nullable] int? fileLineIdx
    ) : base (
      fileLineIdx
     ) 
    {
      RetVal = retVal;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlReturnStmtDto> Read = (ctx, reader) => 
    {
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var retVal = ReadIlExprDtoNullable(ctx, reader);
      var _result = new IlReturnStmtDto(retVal, fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<IlExprDto> ReadIlExprDtoNullable = IlExprDto.Read.NullableClass();
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlReturnStmtDto> Write = (ctx, writer, value) => 
    {
      WriteIntNullable(ctx, writer, value.FileLineIdx);
      WriteIlExprDtoNullable(ctx, writer, value.RetVal);
    };
    public static  CtxWriteDelegate<IlExprDto> WriteIlExprDtoNullable = IlExprDto.Write.NullableClass();
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlReturnStmtDto) obj);
    }
    public bool Equals(IlReturnStmtDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(RetVal, other.RetVal) && Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + (RetVal != null ? RetVal.GetHashCode() : 0);
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlReturnStmtDto (");
      using (printer.IndentCookie()) {
        printer.Print("retVal = "); RetVal.PrintEx(printer); printer.Println();
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:96</p>
  /// </summary>
  public sealed class IlShlOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlShlOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlShlOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlShlOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlShlOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlShlOpDto) obj);
    }
    public bool Equals(IlShlOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlShlOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:98</p>
  /// </summary>
  public sealed class IlShrOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlShrOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlShrOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlShrOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlShrOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlShrOpDto) obj);
    }
    public bool Equals(IlShrOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlShrOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:115</p>
  /// </summary>
  public sealed class IlSizeOfExprDto : IlExprDto
  {
    //fields
    //public fields
    [NotNull] public TypeId TargetType {get; private set;}
    
    //private fields
    //primary constructor
    public IlSizeOfExprDto(
      [NotNull] TypeId targetType,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (targetType == null) throw new ArgumentNullException("targetType");
      
      TargetType = targetType;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlSizeOfExprDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var targetType = TypeId.Read(ctx, reader);
      var _result = new IlSizeOfExprDto(targetType, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlSizeOfExprDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      TypeId.Write(ctx, writer, value.TargetType);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlSizeOfExprDto) obj);
    }
    public bool Equals(IlSizeOfExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(TargetType, other.TargetType) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TargetType.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlSizeOfExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("targetType = "); TargetType.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:176</p>
  /// </summary>
  public sealed class IlStackAllocExprDto : IlExprDto
  {
    //fields
    //public fields
    [NotNull] public IlExprDto Size {get; private set;}
    
    //private fields
    //primary constructor
    public IlStackAllocExprDto(
      [NotNull] IlExprDto size,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (size == null) throw new ArgumentNullException("size");
      
      Size = size;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlStackAllocExprDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var size = IlExprDto.Read(ctx, reader);
      var _result = new IlStackAllocExprDto(size, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlStackAllocExprDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      IlExprDto.Write(ctx, writer, value.Size);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlStackAllocExprDto) obj);
    }
    public bool Equals(IlStackAllocExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Size, other.Size) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Size.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlStackAllocExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("size = "); Size.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:192</p>
  /// </summary>
  public abstract class IlStmtDto{
    //fields
    //public fields
    [Nullable] public int? FileLineIdx {get; private set;}
    
    //private fields
    //primary constructor
    protected IlStmtDto(
      [Nullable] int? fileLineIdx
    )
    {
      FileLineIdx = fileLineIdx;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<IlStmtDto> Read = Polymorphic<IlStmtDto>.ReadAbstract(IlStmtDto_Unknown.Read);
    
    public static CtxWriteDelegate<IlStmtDto> Write = Polymorphic<IlStmtDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlStmtDto_Unknown : IlStmtDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlStmtDto_Unknown(
      [Nullable] int? fileLineIdx
    ) : base (
      fileLineIdx
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlStmtDto_Unknown> Read = (ctx, reader) => 
    {
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var _result = new IlStmtDto_Unknown(fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlStmtDto_Unknown> Write = (ctx, writer, value) => 
    {
      WriteIntNullable(ctx, writer, value.FileLineIdx);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlStmtDto_Unknown) obj);
    }
    public bool Equals(IlStmtDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlStmtDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:63</p>
  /// </summary>
  public sealed class IlStringConstDto : IlConstDto
  {
    //fields
    //public fields
    [NotNull] public string Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlStringConstDto(
      [NotNull] string value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (value == null) throw new ArgumentNullException("value");
      
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlStringConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var value = reader.ReadString();
      var _result = new IlStringConstDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlStringConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlStringConstDto) obj);
    }
    public bool Equals(IlStringConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Value == other.Value && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlStringConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:82</p>
  /// </summary>
  public sealed class IlSubOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlSubOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlSubOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlSubOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlSubOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlSubOpDto) obj);
    }
    public bool Equals(IlSubOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlSubOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:216</p>
  /// </summary>
  public sealed class IlThrowStmtDto : IlEhStmtDto
  {
    //fields
    //public fields
    [NotNull] public IlExprDto Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlThrowStmtDto(
      [NotNull] IlExprDto value,
      [Nullable] int? fileLineIdx
    ) : base (
      fileLineIdx
     ) 
    {
      if (value == null) throw new ArgumentNullException("value");
      
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlThrowStmtDto> Read = (ctx, reader) => 
    {
      var fileLineIdx = ReadIntNullable(ctx, reader);
      var value = IlExprDto.Read(ctx, reader);
      var _result = new IlThrowStmtDto(value, fileLineIdx);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<IlThrowStmtDto> Write = (ctx, writer, value) => 
    {
      WriteIntNullable(ctx, writer, value.FileLineIdx);
      IlExprDto.Write(ctx, writer, value.Value);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlThrowStmtDto) obj);
    }
    public bool Equals(IlThrowStmtDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Value, other.Value) && Equals(FileLineIdx, other.FileLineIdx);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + (FileLineIdx != null ? FileLineIdx.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlThrowStmtDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("fileLineIdx = "); FileLineIdx.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:65</p>
  /// </summary>
  public sealed class IlTypeRefDto : IlConstDto
  {
    //fields
    //public fields
    [NotNull] public TypeId ReferencedType {get; private set;}
    
    //private fields
    //primary constructor
    public IlTypeRefDto(
      [NotNull] TypeId referencedType,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (referencedType == null) throw new ArgumentNullException("referencedType");
      
      ReferencedType = referencedType;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlTypeRefDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var referencedType = TypeId.Read(ctx, reader);
      var _result = new IlTypeRefDto(referencedType, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlTypeRefDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      TypeId.Write(ctx, writer, value.ReferencedType);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlTypeRefDto) obj);
    }
    public bool Equals(IlTypeRefDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(ReferencedType, other.ReferencedType) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + ReferencedType.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlTypeRefDto (");
      using (printer.IndentCookie()) {
        printer.Print("referencedType = "); ReferencedType.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:40</p>
  /// </summary>
  public sealed class IlUint16ConstDto : IlNumConstDto
  {
    //fields
    //public fields
    public ushort Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlUint16ConstDto(
      ushort value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlUint16ConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var value = reader.ReadUShort();
      var _result = new IlUint16ConstDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlUint16ConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlUint16ConstDto) obj);
    }
    public bool Equals(IlUint16ConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Value == other.Value && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlUint16ConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:43</p>
  /// </summary>
  public sealed class IlUint32ConstDto : IlNumConstDto
  {
    //fields
    //public fields
    public uint Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlUint32ConstDto(
      uint value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlUint32ConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var value = reader.ReadUInt();
      var _result = new IlUint32ConstDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlUint32ConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlUint32ConstDto) obj);
    }
    public bool Equals(IlUint32ConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Value == other.Value && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlUint32ConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:46</p>
  /// </summary>
  public sealed class IlUint64ConstDto : IlNumConstDto
  {
    //fields
    //public fields
    public ulong Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlUint64ConstDto(
      ulong value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlUint64ConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var value = reader.ReadULong();
      var _result = new IlUint64ConstDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlUint64ConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlUint64ConstDto) obj);
    }
    public bool Equals(IlUint64ConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Value == other.Value && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlUint64ConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:37</p>
  /// </summary>
  public sealed class IlUint8ConstDto : IlNumConstDto
  {
    //fields
    //public fields
    public byte Value {get; private set;}
    
    //private fields
    //primary constructor
    public IlUint8ConstDto(
      byte value,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlUint8ConstDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var value = reader.ReadUByte();
      var _result = new IlUint8ConstDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlUint8ConstDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlUint8ConstDto) obj);
    }
    public bool Equals(IlUint8ConstDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Value == other.Value && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlUint8ConstDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:69</p>
  /// </summary>
  public abstract class IlUnaryOpDto : IlExprDto
  {
    //fields
    //public fields
    [NotNull] public IlExprDto Operand {get; private set;}
    
    //private fields
    //primary constructor
    protected IlUnaryOpDto(
      [NotNull] IlExprDto operand,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      if (operand == null) throw new ArgumentNullException("operand");
      
      Operand = operand;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlUnaryOpDto> Read = Polymorphic<IlUnaryOpDto>.ReadAbstract(IlUnaryOpDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlUnaryOpDto> Write = Polymorphic<IlUnaryOpDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlUnaryOpDto_Unknown : IlUnaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlUnaryOpDto_Unknown(
      [NotNull] IlExprDto operand,
      [NotNull] TypeId type
    ) : base (
      operand,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlUnaryOpDto_Unknown> Read = (ctx, reader) => 
    {
      var operand = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlUnaryOpDto_Unknown(operand, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlUnaryOpDto_Unknown> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Operand);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlUnaryOpDto_Unknown) obj);
    }
    public bool Equals(IlUnaryOpDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Operand, other.Operand) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Operand.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlUnaryOpDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("operand = "); Operand.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:153</p>
  /// </summary>
  public sealed class IlUnboxExprDto : IlCastExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlUnboxExprDto(
      [NotNull] TypeId targetType,
      [NotNull] IlExprDto operand,
      [NotNull] TypeId type
    ) : base (
      targetType,
      operand,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlUnboxExprDto> Read = (ctx, reader) => 
    {
      var targetType = TypeId.Read(ctx, reader);
      var operand = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlUnboxExprDto(targetType, operand, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlUnboxExprDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.TargetType);
      IlExprDto.Write(ctx, writer, value.Operand);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlUnboxExprDto) obj);
    }
    public bool Equals(IlUnboxExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(TargetType, other.TargetType) && Equals(Operand, other.Operand) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TargetType.GetHashCode();
        hash = hash * 31 + Operand.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlUnboxExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("targetType = "); TargetType.PrintEx(printer); printer.Println();
        printer.Print("operand = "); Operand.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:174</p>
  /// </summary>
  public sealed class IlUnmanagedDerefExprDto : IlDerefExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlUnmanagedDerefExprDto(
      [NotNull] IlExprDto value,
      [NotNull] TypeId type
    ) : base (
      value,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlUnmanagedDerefExprDto> Read = (ctx, reader) => 
    {
      var value = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlUnmanagedDerefExprDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlUnmanagedDerefExprDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Value);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlUnmanagedDerefExprDto) obj);
    }
    public bool Equals(IlUnmanagedDerefExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Value, other.Value) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlUnmanagedDerefExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:170</p>
  /// </summary>
  public sealed class IlUnmanagedRefExprDto : IlRefExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlUnmanagedRefExprDto(
      [NotNull] IlExprDto value,
      [NotNull] TypeId type
    ) : base (
      value,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlUnmanagedRefExprDto> Read = (ctx, reader) => 
    {
      var value = IlExprDto.Read(ctx, reader);
      var type = TypeId.Read(ctx, reader);
      var _result = new IlUnmanagedRefExprDto(value, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlUnmanagedRefExprDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Value);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlUnmanagedRefExprDto) obj);
    }
    public bool Equals(IlUnmanagedRefExprDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Value, other.Value) && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlUnmanagedRefExprDto (");
      using (printer.IndentCookie()) {
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:32</p>
  /// </summary>
  public abstract class IlValueDto : IlExprDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    protected IlValueDto(
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlValueDto> Read = Polymorphic<IlValueDto>.ReadAbstract(IlValueDto_Unknown.Read);
    
    public static new CtxWriteDelegate<IlValueDto> Write = Polymorphic<IlValueDto>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class IlValueDto_Unknown : IlValueDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlValueDto_Unknown(
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlValueDto_Unknown> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var _result = new IlValueDto_Unknown(type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlValueDto_Unknown> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlValueDto_Unknown) obj);
    }
    public bool Equals(IlValueDto_Unknown other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlValueDto_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:253</p>
  /// </summary>
  public sealed class IlVarAccessDto : IlValueDto
  {
    //fields
    //public fields
    public IlVarKind Kind {get; private set;}
    public int Index {get; private set;}
    
    //private fields
    //primary constructor
    public IlVarAccessDto(
      IlVarKind kind,
      int index,
      [NotNull] TypeId type
    ) : base (
      type
     ) 
    {
      Kind = kind;
      Index = index;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlVarAccessDto> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var kind = (IlVarKind)reader.ReadInt();
      var index = reader.ReadInt();
      var _result = new IlVarAccessDto(kind, index, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlVarAccessDto> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write((int)value.Kind);
      writer.Write(value.Index);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlVarAccessDto) obj);
    }
    public bool Equals(IlVarAccessDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Kind == other.Kind && Index == other.Index && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + (int) Kind;
        hash = hash * 31 + Index.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlVarAccessDto (");
      using (printer.IndentCookie()) {
        printer.Print("kind = "); Kind.PrintEx(printer); printer.Println();
        printer.Print("index = "); Index.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:245</p>
  /// </summary>
  public enum IlVarKind {
    local,
    temp,
    err
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:94</p>
  /// </summary>
  public sealed class IlXorOpDto : IlBinaryOpDto
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    public IlXorOpDto(
      [NotNull] IlExprDto lhv,
      [NotNull] IlExprDto rhv,
      bool isChecked,
      bool isUnsigned,
      [NotNull] TypeId type
    ) : base (
      lhv,
      rhv,
      isChecked,
      isUnsigned,
      type
     ) 
    {
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<IlXorOpDto> Read = (ctx, reader) => 
    {
      var lhv = IlExprDto.Read(ctx, reader);
      var rhv = IlExprDto.Read(ctx, reader);
      var isChecked = reader.ReadBool();
      var isUnsigned = reader.ReadBool();
      var type = TypeId.Read(ctx, reader);
      var _result = new IlXorOpDto(lhv, rhv, isChecked, isUnsigned, type);
      return _result;
    };
    
    public static new CtxWriteDelegate<IlXorOpDto> Write = (ctx, writer, value) => 
    {
      IlExprDto.Write(ctx, writer, value.Lhv);
      IlExprDto.Write(ctx, writer, value.Rhv);
      writer.Write(value.IsChecked);
      writer.Write(value.IsUnsigned);
      TypeId.Write(ctx, writer, value.Type);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((IlXorOpDto) obj);
    }
    public bool Equals(IlXorOpDto other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Lhv, other.Lhv) && Equals(Rhv, other.Rhv) && IsChecked == other.IsChecked && IsUnsigned == other.IsUnsigned && Equals(Type, other.Type);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Lhv.GetHashCode();
        hash = hash * 31 + Rhv.GetHashCode();
        hash = hash * 31 + IsChecked.GetHashCode();
        hash = hash * 31 + IsUnsigned.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("IlXorOpDto (");
      using (printer.IndentCookie()) {
        printer.Print("lhv = "); Lhv.PrintEx(printer); printer.Println();
        printer.Print("rhv = "); Rhv.PrintEx(printer); printer.Println();
        printer.Print("isChecked = "); IsChecked.PrintEx(printer); printer.Println();
        printer.Print("isUnsigned = "); IsUnsigned.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: IlMethodBodyModel.kt:25</p>
  /// </summary>
  public sealed class InstanceId : IPrintable, IEquatable<InstanceId>
  {
    //fields
    //public fields
    [NotNull] public TypeId Type {get; private set;}
    [NotNull] public string Name {get; private set;}
    
    //private fields
    //primary constructor
    public InstanceId(
      [NotNull] TypeId type,
      [NotNull] string name
    )
    {
      if (type == null) throw new ArgumentNullException("type");
      if (name == null) throw new ArgumentNullException("name");
      
      Type = type;
      Name = name;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out TypeId type, [NotNull] out string name)
    {
      type = Type;
      name = Name;
    }
    //statics
    
    public static CtxReadDelegate<InstanceId> Read = (ctx, reader) => 
    {
      var type = TypeId.Read(ctx, reader);
      var name = reader.ReadString();
      var _result = new InstanceId(type, name);
      return _result;
    };
    
    public static CtxWriteDelegate<InstanceId> Write = (ctx, writer, value) => 
    {
      TypeId.Write(ctx, writer, value.Type);
      writer.Write(value.Name);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((InstanceId) obj);
    }
    public bool Equals(InstanceId other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Type, other.Type) && Name == other.Name;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Type.GetHashCode();
        hash = hash * 31 + Name.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("InstanceId (");
      using (printer.IndentCookie()) {
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
}
